{% extends "hidden/hidden_structure.html" %}

{% block title %}NetFang Secured Router{% endblock %}

{% block header_title %}NetFang Secured Router - {{ hostname }}{% endblock %}

{% block main_content %}
    <div class="state-indicator">
        <strong>NetFang Status:</strong>
        <span id="state">{{ state }}</span>
        <div id="scanningIndicator" class="scanning-indicator">
            <div class="scanning-pulse"></div>
            <span>Scanning network...</span>
        </div>
        <div class="state-status-bar">
            <div class="state-status-progress"></div>
        </div>
        <div id="stateDescription" class="state-description mt-2"></div>
    </div>

    <!-- Current Processes Display -->
    <div id="currentProcessesContainer" class="current-processes-container">
        <!-- Individual process boxes will be dynamically added here -->
    </div>

    <div class="dashboard-container">
        <!-- Network Information -->
        <div class="dashboard-panel">
            <div class="panel-header">
                <h2>Networks</h2>
                <span class="panel-toggle">▼</span>
            </div>
            <div class="panel-content">
                <div class="table-container">
                    <table class="data-table" id="networksTable">
                        <thead>
                            <tr>
                                <th>MAC Address</th>
                                <th>Status</th>
                                <th>Last Seen</th>
                                <th>Actions</th>
                            </tr>
                        </thead>
                        <tbody>
                            <!-- Data will be populated by JavaScript -->
                        </tbody>
                    </table>
                </div>
            </div>
        </div>
        
        <!-- Devices Information -->
        <div class="dashboard-panel">
            <div class="panel-header">
                <h2>Devices</h2>
                <span class="panel-toggle">▼</span>
            </div>
            <div class="panel-content">
                <div class="table-container">
                    <table class="data-table" id="devicesTable">
                        <thead>
                            <tr>
                                <th>IP Address</th>
                                <th>MAC Address</th>
                                <th>Vendor</th>
                                <th>Network</th>
                                <th>Actions</th>
                            </tr>
                        </thead>
                        <tbody>
                            <!-- Data will be populated by JavaScript -->
                        </tbody>
                    </table>
                </div>
            </div>
        </div>
        
        <!-- Plugin Logs -->
        <div class="dashboard-panel">
            <div class="panel-header">
                <h2>Plugin Logs</h2>
                <span class="panel-toggle collapsed">▼</span>
            </div>
            <div class="panel-content collapsed">
                <div class="table-container">
                    <table class="data-table" id="pluginLogsTable">
                        <thead>
                            <tr>
                                <th>Plugin</th>
                                <th>Event</th>
                                <th>Timestamp</th>
                            </tr>
                        </thead>
                        <tbody>
                            <!-- Data will be populated by JavaScript -->
                        </tbody>
                    </table>
                </div>
                <div class="table-actions">
                    <button id="clearLogsButton" class="clear-logs-button">Clear Log Display</button>
                    <button id="autoScrollToggle" class="auto-scroll-button active">Auto-scroll: ON</button>
                </div>
            </div>
        </div>
        
        <!-- Plugin Actions -->
        <div class="dashboard-panel">
            <div class="panel-header">
                <h2>Available Actions</h2>
                <span class="panel-toggle">▼</span>
            </div>
            <div class="panel-content">
                <div class="action-container" id="pluginActionsContainer">
                    <p class="no-actions-message">No actions available from plugins.</p>
                    <!-- Actions will be populated by JavaScript -->
                </div>
            </div>
        </div>
    </div>
    
    <div class="dashboard-controls">
        <button id="syncButton" class="sync-button">Sync Dashboard</button>
        <button id="restartServiceButton" class="service-button">Restart Netfang Service</button>
        <div id="statusMessage" class="status-message"></div>
    </div>
{% endblock %}

{% block additional_scripts %}
<script>
    // socket is already established in the global scope (from hidden_structure.html)
    
    // Connection status handling
    socket.on('connect', function() {
        console.log('Connected to server via Socket.IO');
        document.getElementById('statusMessage').textContent = 'Connected to server';
        document.getElementById('statusMessage').style.opacity = 1;
        setTimeout(() => {
            document.getElementById('statusMessage').style.opacity = 0;
        }, 2000);
    });
    
    socket.on('connect_error', function(error) {
        console.error('Socket.IO connection error:', error);
        document.getElementById('statusMessage').textContent = 'Connection error! Trying to reconnect...';
        document.getElementById('statusMessage').style.opacity = 1;
        alertify.error('Connection to server lost. Trying to reconnect...', 0);
    });
    
    socket.on('reconnect', function(attemptNumber) {
        console.log('Reconnected to server after ' + attemptNumber + ' attempts');
        document.getElementById('statusMessage').textContent = 'Reconnected to server';
        document.getElementById('statusMessage').style.opacity = 1;
        setTimeout(() => {
            document.getElementById('statusMessage').style.opacity = 0;
        }, 2000);
        alertify.dismissAll();
        alertify.success('Reconnected to server');
        // Refresh dashboard data after reconnect
        syncDashboard();
    });

    // Configure alertify defaults
    alertify.defaults.notifier.position = 'top-right';
    alertify.defaults.notifier.delay = 5;
    alertify.defaults.transition = "slide";
    alertify.defaults.theme.ok = "btn btn-primary";
    alertify.defaults.theme.cancel = "btn btn-danger";
    alertify.defaults.theme.input = "form-control";

    const stateElement = document.getElementById("state");
    const scanningIndicator = document.getElementById("scanningIndicator");
    const stateIndicator = document.querySelector(".state-indicator");
    const stateStatusProgress = document.querySelector(".state-status-progress");
    const stateDescription = document.getElementById("stateDescription");
    const dashboardContainer = document.querySelector(".dashboard-container");
    let previousState = '{{ state }}';
    let currentIntervalID = null;
    let scanCompletedTimeout = null;
    
    // Current process display elements
    const currentProcessesContainer = document.getElementById('currentProcessesContainer');
    
    // Plugin logs elements
    const pluginLogsTable = document.getElementById('pluginLogsTable').getElementsByTagName('tbody')[0];
    const clearLogsButton = document.getElementById('clearLogsButton');
    const autoScrollToggle = document.getElementById('autoScrollToggle');
    let autoScrollEnabled = true;
    
    // Networks and devices tables
    const networksTable = document.getElementById('networksTable').getElementsByTagName('tbody')[0];
    const devicesTable = document.getElementById('devicesTable').getElementsByTagName('tbody')[0];
    
    // Plugin actions container
    const pluginActionsContainer = document.getElementById('pluginActionsContainer');
    
    // Track registered actions
    let registeredActions = {};
    
    // Map network IDs to MAC addresses for action handling
    let networkIdToMac = {};
    let deviceIdToInfo = {};

    // Initialize state descriptions
    const stateDescriptions = {
        'WAITING_FOR_NETWORK': 'NetFang is waiting for a network connection. Please check your network cable or Wi-Fi connection.',
        'DISCONNECTED': 'Network connection lost. NetFang will automatically try to reconnect when a network is available.',
        'RECONNECTING': 'Attempting to reconnect to the network...',
        'CONNECTING': 'Establishing connection to the network...',
        'CONNECTED_KNOWN': 'Connected to a known network. Network scan completed. Enhanced security features are active.',
        'CONNECTED_HOME': 'Connected to your home network. Network scan completed. Full security features are active.',
        'CONNECTED_NEW': 'Connected to a new, unrecognized network. Network scan completed with security measures in place.',
        'CONNECTED_BLACKLISTED': 'Warning: Connected to a blacklisted network! Enhanced protection measures activated.',
        'SCANNING_IN_PROGRESS': 'Network scan in progress. Discovering devices and potential threats...',
        'SCAN_COMPLETED': 'Network scan completed. Results have been analyzed and security measures are in place.',
        'PERFORM_ACTION': 'Executing security action...'
    };

    // Update the state indicator, progress bar, and container styling based on current state
    function updateStateIndicator(state) {
        // Remove any existing state classes
        stateIndicator.className = "state-indicator";
        
        // Add the new state class
        stateIndicator.classList.add(`state-${state}`);
        
        // Add class to dashboard container for broader styling
        dashboardContainer.className = "dashboard-container";
        dashboardContainer.classList.add(`dashboard-state-${state}`);
        
        // Update progress bar visibility and animation based on state
        if (state === "SCANNING_IN_PROGRESS" || state === "CONNECTING" || state === "RECONNECTING") {
            scanningIndicator.classList.add('active');
            stateStatusProgress.style.animation = "progressAnim 2s infinite";
            
            // For scanning state, show an alertify notification if not already shown
            if (state === "SCANNING_IN_PROGRESS") {
                alertify.notify('Network scan in progress...', 'info', 0, function(){});
            }
        } else {
            scanningIndicator.classList.remove('active');
            stateStatusProgress.style.animation = "none";
            
            // Clear any existing scan completed timeout
            if (scanCompletedTimeout) {
                clearTimeout(scanCompletedTimeout);
                scanCompletedTimeout = null;
            }
            
            // Dismiss any persistent notifications
            alertify.dismissAll();
            
            // Set fixed progress for complete states
            if (state === "CONNECTED_HOME" || state === "CONNECTED_KNOWN" || state === "SCAN_COMPLETED") {
                stateStatusProgress.style.width = "100%";
                
                // If transition from scanning to completed, show a success notification
                if (previousState === "SCANNING_IN_PROGRESS" && state === "SCAN_COMPLETED") {
                    alertify.success('Network scan completed successfully!');
                    
                    // After scan completes, we'll stay on SCAN_COMPLETED temporarily then auto-transition back
                    // to the appropriate connected state after a few seconds (this is cosmetic only)
                    scanCompletedTimeout = setTimeout(() => {
                        // This will be handled by the server but we'll update the UI proactively
                        // for a smoother experience
                        syncDashboard();
                    }, 5000);
                }
            } else if (state === "CONNECTED_NEW") {
                stateStatusProgress.style.width = "75%";
            } else if (state === "CONNECTED_BLACKLISTED") {
                stateStatusProgress.style.width = "100%";
                stateStatusProgress.style.background = "linear-gradient(to right, #ef5350, #e57373)";
                
                // Show a warning notification for blacklisted networks
                alertify.error('Warning: Connected to a blacklisted network!', 0);
            } else if (state === "DISCONNECTED" || state === "WAITING_FOR_NETWORK") {
                stateStatusProgress.style.width = "25%";
                
                // Show a notification for disconnection
                if (previousState !== "DISCONNECTED" && previousState !== "WAITING_FOR_NETWORK") {
                    alertify.warning('Network connection lost.');
                }
            } else {
                stateStatusProgress.style.width = "50%";
            }
        }
        
        // Update state description
        stateDescription.textContent = stateDescriptions[state] || '';
        
        // Update the buttons style based on state
        updateButtonStyles(state);
        
        // Adjust table headers based on state
        updateTableStyles(state);
    }
    
    // Update button styles based on state
    function updateButtonStyles(state) {
        const syncButton = document.getElementById('syncButton');
        const restartButton = document.getElementById('restartServiceButton');
        
        // Reset button classes
        syncButton.className = 'sync-button';
        restartButton.className = 'service-button';
        
        if (state === "CONNECTED_BLACKLISTED") {
            restartButton.classList.add('warning-button');
            restartButton.textContent = "Security Reset";
        } else {
            restartButton.textContent = "Restart Netfang Service";
        }
        
        if (state === "SCANNING_IN_PROGRESS") {
            syncButton.disabled = true;
            syncButton.classList.add('disabled-button');
        } else {
            syncButton.disabled = false;
            syncButton.classList.remove('disabled-button');
        }
    }
    
    // Update table styling based on state
    function updateTableStyles(state) {
        const tableHeaders = document.querySelectorAll('.data-table th');
        
        // Reset all table header styles
        tableHeaders.forEach(th => {
            th.style.backgroundColor = '';
            th.style.color = '';
            th.style.borderBottomColor = '';
        });
        
        // Apply state-specific styles
        if (state === "CONNECTED_BLACKLISTED") {
            tableHeaders.forEach(th => {
                th.style.backgroundColor = '#ffebee';
                th.style.borderBottomColor = '#ef5350';
            });
        } else if (state === "CONNECTED_HOME" || state === "SCAN_COMPLETED") {
            tableHeaders.forEach(th => {
                th.style.backgroundColor = '#e8f5e9';
                th.style.borderBottomColor = '#43a047';
            });
        } else if (state === "SCANNING_IN_PROGRESS") {
            tableHeaders.forEach(th => {
                th.style.backgroundColor = '#e0f7fa';
                th.style.borderBottomColor = '#26c6da';
            });
        }
    }

    // Initialize collapsible panels
    document.querySelectorAll('.panel-header').forEach(header => {
        header.addEventListener('click', () => {
            const toggle = header.querySelector('.panel-toggle');
            const content = header.nextElementSibling;
            
            toggle.classList.toggle('collapsed');
            content.classList.toggle('collapsed');
        });
    });

    // Typewriter effect for 'state'
    function typeText(element, text) {
        if (currentIntervalID !== null) {
            clearInterval(currentIntervalID);
        }
        let index = 0;
        element.innerText = '';
        currentIntervalID = setInterval(() => {
            if (index < text.length) {
                element.innerText += text.charAt(index);
                index++;
            } else {
                clearInterval(currentIntervalID);
                currentIntervalID = null;
            }
        }, 50);
    }

    // Listen for state updates from the server
    socket.on("state_update", (data) => {
        console.log(`[${new Date().toLocaleTimeString()}] State update received:`, data);
        const newState = data.state || 'Unknown';

        if (newState !== previousState) {
            // Update state display
            typeText(stateElement, newState);
            updateStateIndicator(newState);
            
            // Record new state
            previousState = newState;
        }
    });

    // Format timestamp for display
    function formatTimestamp(timestamp) {
        try {
            const date = new Date(timestamp);
            return date.toLocaleString();
        } catch (e) {
            return 'Invalid time';
        }
    }
    
    // Toggle fingerprint display
    function setupFingerprintToggles() {
        document.querySelectorAll('.show-fingerprint').forEach(button => {
            button.addEventListener('click', function() {
                const dataElement = this.nextElementSibling;
                if (dataElement.style.display === 'block') {
                    dataElement.style.display = 'none';
                    this.textContent = 'Show Fingerprint';
                } else {
                    dataElement.style.display = 'block';
                    this.textContent = 'Hide Fingerprint';
                }
            });
        });
    }
    
    // Set up action button click handlers
    function setupActionButtons() {
        document.querySelectorAll('.plugin-action-button').forEach(button => {
            button.addEventListener('click', function() {
                const actionId = this.dataset.actionId;
                const action = registeredActions[actionId];
                
                if (!action) return;
                
                let targetId = this.dataset.targetId;
                
                console.log(`Executing action: ${action.action_name} (${action.plugin_name}) on target ${targetId}`);
                
                // Trigger API call to execute action
                fetch('/plugin/action', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        plugin_name: action.plugin_name,
                        action_id: action.action_id,
                        target_type: action.target_type,
                        target_id: targetId
                    })
                })
                .then(response => response.json())
                .then(data => {
                    if (data.status === 'success') {
                        alertify.success(data.message || 'Action executed successfully');
                    } else {
                        alertify.error(data.message || 'Failed to execute action');
                    }
                })
                .catch(error => {
                    alertify.error(`Error: ${error.message}`);
                });
            });
        });
    }
    
    // Handle dashboard data sync
    function updateDashboardData(data) {
        // Clear existing tables
        networksTable.innerHTML = '';
        devicesTable.innerHTML = '';
        
        // Track network IDs to MACs for action handling
        networkIdToMac = {};
        deviceIdToInfo = {};
        
        // Populate Networks table
        data.networks.forEach(network => {
            const row = networksTable.insertRow();
            
            const statusClass = network.is_home ? 'network-home' : 
                               (network.is_blacklisted ? 'network-blacklisted' : '');
            
            const statusText = network.is_home ? 'Home' : 
                              (network.is_blacklisted ? 'Blacklisted' : 'Known');
            
            // Store mapping of ID to MAC
            networkIdToMac[network.id] = network.mac_address;
            
            // Create action buttons for this network
            const actionButtons = getActionButtonsHtml('network', network.id);
            
            row.innerHTML = `
                <td>${network.mac_address}</td>
                <td class="${statusClass}">${statusText}</td>
                <td>${formatTimestamp(network.last_seen)}</td>
                <td>${actionButtons}</td>
            `;
        });
        
        // Populate Devices table
        data.devices.forEach(device => {
            const row = devicesTable.insertRow();
            
            // Store device info for action handling
            deviceIdToInfo[device.id] = {
                ip: device.ip_address,
                mac: device.mac_address,
                network_id: device.network_id
            };
            
            // Check if we have fingerprint data
            const hasFingerprintData = device.fingerprint && device.fingerprint !== 'None';
            const fingerprintHtml = hasFingerprintData ? 
                `<span class="show-fingerprint">Show Fingerprint</span>
                 <div class="fingerprint-data">${device.fingerprint}</div>` : '';
            
            // Create action buttons for this device
            const actionButtons = getActionButtonsHtml('device', device.id);
            
            // Get network name if available
            const networkInfo = device.network_id && networkIdToMac[device.network_id] ? 
                `${networkIdToMac[device.network_id]}` : 'Unknown';
                
            row.innerHTML = `
                <td>${device.ip_address || 'N/A'}</td>
                <td>${device.mac_address || 'N/A'}</td>
                <td>${device.vendor || 'Unknown'}</td>
                <td>${networkInfo}</td>
                <td>${fingerprintHtml} ${actionButtons}</td>
            `;
        });
        
        // Populate Plugin Logs table - only replace all if it's more than a regular update
        if (data.plugin_logs && data.plugin_logs.length > 5) {
            pluginLogsTable.innerHTML = '';
            
            data.plugin_logs.sort((a, b) => {
                return new Date(b.timestamp) - new Date(a.timestamp);
            }).forEach(log => {
                const row = pluginLogsTable.insertRow();
                row.innerHTML = `
                    <td>${log.plugin_name}</td>
                    <td>${log.event}</td>
                    <td>${formatTimestamp(log.timestamp)}</td>
                `;
            });
        }
        
        // Set up fingerprint toggle buttons
        setupFingerprintToggles();
        
        // Set up action buttons
        setupActionButtons();
        
        // Update actions panel with global actions
        updateActionsPanel();
        
        // Show success message with animation
        const statusMessage = document.getElementById('statusMessage');
        statusMessage.textContent = `Dashboard updated at ${new Date().toLocaleTimeString()}`;
        statusMessage.style.opacity = 1;
        
        setTimeout(() => {
            statusMessage.style.opacity = 0;
        }, 3000);
    }
    
    // Generate HTML for action buttons based on registered actions
    function getActionButtonsHtml(targetType, targetId) {
        let actionButtonsHtml = '';
        
        // Find actions for this target type
        Object.values(registeredActions).forEach(action => {
            if (action.target_type === targetType && 
                (action.target_id === null || action.target_id === targetId.toString())) {
                
                actionButtonsHtml += `
                    <button 
                        class="plugin-action-button" 
                        data-action-id="${action.action_id}" 
                        data-target-id="${targetId}"
                        title="${action.description}"
                    >
                        ${action.action_name}
                    </button>
                `;
            }
        });
        
        return actionButtonsHtml;
    }
    
    // Update the actions panel with global (system-wide) actions
    function updateActionsPanel() {
        // Clear current actions
        pluginActionsContainer.innerHTML = '';
        
        // Find all system actions
        const systemActions = Object.values(registeredActions).filter(
            action => action.target_type === 'system'
        );
        
        if (systemActions.length === 0) {
            pluginActionsContainer.innerHTML = '<p class="no-actions-message">No actions available from plugins.</p>';
            return;
        }
        
        // Group actions by plugin
        const actionsByPlugin = {};
        systemActions.forEach(action => {
            if (!actionsByPlugin[action.plugin_name]) {
                actionsByPlugin[action.plugin_name] = [];
            }
            actionsByPlugin[action.plugin_name].push(action);
        });
        
        // Create action elements for each plugin
        Object.entries(actionsByPlugin).forEach(([pluginName, actions]) => {
            const pluginActionGroup = document.createElement('div');
            pluginActionGroup.className = 'plugin-action-group';
            
            const pluginHeader = document.createElement('h3');
            pluginHeader.textContent = pluginName;
            pluginActionGroup.appendChild(pluginHeader);
            
            const actionButtons = document.createElement('div');
            actionButtons.className = 'action-buttons';
            
            actions.forEach(action => {
                const button = document.createElement('button');
                button.className = 'plugin-action-button';
                button.dataset.actionId = action.action_id;
                button.dataset.targetId = action.target_id || 'system';
                button.textContent = action.action_name;
                button.title = action.description;
                actionButtons.appendChild(button);
            });
            
            pluginActionGroup.appendChild(actionButtons);
            pluginActionsContainer.appendChild(pluginActionGroup);
        });
        
        // Set up action buttons
        setupActionButtons();
    }
    
    // Add plugin log to the table
    function addPluginLog(log) {
        // Create a new row at the beginning of the table
        const row = pluginLogsTable.insertRow(0);
        row.innerHTML = `
            <td>${log.plugin_name}</td>
            <td>${log.event}</td>
            <td>${formatTimestamp(log.timestamp)}</td>
        `;
        
        // Flash highlight the new row
        row.classList.add('new-log-entry');
        setTimeout(() => {
            row.classList.remove('new-log-entry');
        }, 2000);
        
        // Auto-scroll to keep the newest logs visible
        if (autoScrollEnabled) {
            row.scrollIntoView({ behavior: 'smooth', block: 'start' });
        }
        
        // Limit table size to prevent performance issues
        if (pluginLogsTable.rows.length > 1000) {
            pluginLogsTable.deleteRow(pluginLogsTable.rows.length - 1);
        }
    }
    
    // Handle command output for multiple processes
    function handleCommandOutput(data) {
        const processId = data.process_id;
        let processContainer = document.getElementById(`process-${processId}`);

        // If the process container doesn't exist, create it
        if (!processContainer) {
            processContainer = document.createElement('div');
            processContainer.id = `process-${processId}`;
            processContainer.className = 'current-process-container';

            processContainer.innerHTML = `
                <div class="current-process-header">
                    <h3>Current Process <span class="current-process-plugin">(${data.plugin_name})</span></h3>
                    <button class="close-button" onclick="closeProcess('${processId}')">×</button>
                </div>
                <div class="current-process-command">${data.command}</div>
                <div class="current-process-output" id="output-${processId}"></div>
            `;

            document.getElementById('currentProcessesContainer').appendChild(processContainer);
        }

        // Add output line to the process output container
        const outputContainer = document.getElementById(`output-${processId}`);
        const outputLine = document.createElement('div');
        outputLine.className = 'output-line';
        outputLine.textContent = data.output;
        outputContainer.appendChild(outputLine);

        // Auto-scroll output
        outputContainer.scrollTop = outputContainer.scrollHeight;

        // If command is complete, add a completion marker
        if (data.is_complete) {
            const completionLine = document.createElement('div');
            completionLine.className = 'completion-line';
            completionLine.textContent = '--- Process completed ---';
            outputContainer.appendChild(completionLine);
        }
    }

    // Close a specific process output box
    function closeProcess(processId) {
        const processContainer = document.getElementById(`process-${processId}`);
        if (processContainer) {
            processContainer.remove();
        }
    }

    // Handle current process update
    function handleCurrentProcess(data) {
        if (data === null) {
            // Clear current process display
            currentProcessesContainer.innerHTML = '';
            return;
        }
        
        const processId = data.process_id;
        let processContainer = document.getElementById(`process-${processId}`);

        // If the process container doesn't exist, create it
        if (!processContainer) {
            processContainer = document.createElement('div');
            processContainer.id = `process-${processId}`;
            processContainer.className = 'current-process-container';

            processContainer.innerHTML = `
                <div class="current-process-header">
                    <h3>Current Process <span class="current-process-plugin">(${data.plugin_name})</span></h3>
                    <button class="close-button" onclick="closeProcess('${processId}')">×</button>
                </div>
                <div class="current-process-command">${data.command}</div>
                <div class="current-process-output" id="output-${processId}"></div>
            `;

            currentProcessesContainer.appendChild(processContainer);
        }

        // Add start message
        const startLine = document.createElement('div');
        startLine.className = 'start-line';
        startLine.textContent = `Process started at ${formatTimestamp(data.start_time)}`;
        const outputContainer = document.getElementById(`output-${processId}`);
        outputContainer.innerHTML = '';
        outputContainer.appendChild(startLine);
    }
    
    // Listen for dashboard data from the server
    socket.on('dashboard_data', (data) => {
        console.log(`[${new Date().toLocaleTimeString()}] Dashboard data received:`, data);
        updateDashboardData(data);
    });
    
    // Listen for real-time plugin logs
    socket.on('plugin_log', (log) => {
        console.log(`[${new Date().toLocaleTimeString()}] Plugin log received:`, log);
        addPluginLog(log);
    });
    
    // Listen for command output streaming
    socket.on('command_output', (data) => {
        console.log(`[${new Date().toLocaleTimeString()}] Command output:`, data);
        handleCommandOutput(data);
    });
    
    // Listen for current process updates
    socket.on('current_process', (data) => {
        console.log(`[${new Date().toLocaleTimeString()}] Current process update:`, data);
        handleCurrentProcess(data);
    });
    
    // Listen for plugin action registration
    socket.on('register_action', (action) => {
        console.log(`[${new Date().toLocaleTimeString()}] Action registered:`, action);
        
        // Store the action
        registeredActions[action.action_id] = action;
        
        // Update action panels
        updateActionsPanel();
        
        // Notify user - change alertify.info to alertify.notify with 'info' type
        alertify.notify(`New action available: ${action.action_name}`, 'info', 3);
    });
    
    // Listen for alert notifications
    socket.on('alert_sync', (data) => {
        console.log(`[${new Date().toLocaleTimeString()}] Alert received:`, data);
        if (data.level === 'ERROR' || data.level === 'CRITICAL') {
            alertify.error(data.message, 0);  // 0 means it stays until dismissed
        } else if (data.level === 'WARNING') {
            alertify.warning(data.message, 10);
        } else if (data.level === 'INFO') {
            alertify.info(data.message, 5);
        } else if (data.level === 'SUCCESS') {
            alertify.success(data.message, 5);
        }
    });
    
    // Sync dashboard function
    window.syncDashboard = function() {
        socket.emit('sync_dashboard');
        const statusMessage = document.getElementById('statusMessage');
        statusMessage.textContent = 'Syncing...';
        statusMessage.style.opacity = 1;
        const syncButton = document.getElementById('syncButton');
        syncButton.classList.add('syncing');
        
        setTimeout(() => {
            syncButton.classList.remove('syncing');
        }, 1000);
    };
    
    // Clear logs display handler
    clearLogsButton.addEventListener('click', () => {
        // Only clear the display, not the database
        pluginLogsTable.innerHTML = '';
        alertify.info('Log display cleared');
    });
    
    // Auto-scroll toggle handler
    autoScrollToggle.addEventListener('click', () => {
        autoScrollEnabled = !autoScrollEnabled;
        autoScrollToggle.textContent = autoScrollEnabled ? 'Auto-scroll: ON' : 'Auto-scroll: OFF';
        autoScrollToggle.classList.toggle('active', autoScrollEnabled);
    });
    
    // Close process output handler
    closeProcessButton.addEventListener('click', () => {
        currentProcessContainer.style.display = 'none';
        currentProcessOutput.innerHTML = '';
    });
    
    // Handle manual sync button click
    document.getElementById('syncButton').addEventListener('click', window.syncDashboard);
    
    // Handle service restart button
    document.getElementById('restartServiceButton').addEventListener('click', async () => {
        if (confirm('Are you sure you want to restart the Netfang service?')) {
            const statusMessage = document.getElementById('statusMessage');
            statusMessage.textContent = 'Restarting service...';
            statusMessage.style.opacity = 1;
            
            try {
                const response = await fetch('/update', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    }
                });
                
                const data = await response.json();
                
                if (data.status === 'success') {
                    statusMessage.textContent = data.message;
                    // Show success notification
                    alertify.success(data.message, 5);
                } else {
                    statusMessage.textContent = data.message;
                    // Show error notification
                    alertify.error(data.message, 5);
                }
            } catch (error) {
                statusMessage.textContent = `Error: ${error.message}`;
                alertify.error(`Error restarting service: ${error.message}`, 5);
            }
            
            // Clear status message after 5 seconds
            setTimeout(() => {
                statusMessage.style.opacity = 0;
            }, 5000);
        }
    });

    // Check initial state for scanning and update indicator
    updateStateIndicator(previousState);
    
    // Auto-refresh dashboard data every 30 seconds
    setInterval(window.syncDashboard, 30000);

    // Request initial dashboard data when connected
    document.addEventListener('DOMContentLoaded', function() {
        if (socket.connected) {
            window.syncDashboard();
        }
    });

    // Set up panel toggles
    document.querySelectorAll('.panel-toggle').forEach(toggle => {
        toggle.addEventListener('click', function() {
            // Toggle collapsed class on the toggle element
            this.classList.toggle('collapsed');
            
            // Find the panel content (next sibling to the panel header)
            const panelContent = this.parentElement.nextElementSibling;
            
            // Toggle collapsed class on the panel content
            panelContent.classList.toggle('collapsed');
        });
    });
</script>
{% endblock %}