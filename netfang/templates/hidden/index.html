{% extends "hidden/hidden_structure.html" %}

{% block title %}NetFang Secured Router{% endblock %}

{% block header_title %}NetFang Secured Router - {{ hostname }}{% endblock %}

{% block main_content %}
    <!-- State Indicator -->
    <div class="state-indicator state-{{ state | lower | replace('_', '-') }}">
        <strong>NetFang Status:</strong>
        <span id="state">{{ state }}</span>
        <div id="scanningIndicator" class="scanning-indicator">
            <div class="scanning-pulse"></div>
            <span>Scanning network...</span>
        </div>
        <div class="state-status-bar">
            <div class="state-status-progress"></div>
        </div>
        <div id="stateDescription" class="state-description mt-2" data-bs-toggle="tooltip" data-bs-placement="bottom" title="Current operational status and context.">
            <!-- Description populated by JS -->
        </div>
    </div>

    <!-- Current Processes Display -->
    <div id="currentProcessesContainer" class="current-processes-container">
        <!-- Dynamically added process boxes -->
    </div>

    <!-- Dashboard Panels -->
    <div class="dashboard-container dashboard-state-{{ state | lower | replace('_', '-') }}">
        <!-- Network Information -->
        <div class="dashboard-panel">
            <div class="panel-header" data-bs-toggle="tooltip" title="Detected networks and their status.">
                <h2>Networks</h2>
                <span class="panel-toggle">▼</span>
            </div>
            <div class="panel-content">
                <div class="table-container">
                    <table class="data-table" id="networksTable">
                        <thead>
                            <tr>
                                <th>MAC Address</th>
                                <th>Status</th>
                                <th>Last Seen</th>
                                <th>Actions</th>
                            </tr>
                        </thead>
                        <tbody>
                            <!-- Populated by JS -->
                            <tr><td colspan="4" class="text-center p-3">Loading network data...</td></tr>
                        </tbody>
                    </table>
                </div>
            </div>
        </div>

        <!-- Devices Information -->
        <div class="dashboard-panel">
            <div class="panel-header" data-bs-toggle="tooltip" title="Devices detected on the current or known networks.">
                <h2>Devices</h2>
                <span class="panel-toggle">▼</span>
            </div>
            <div class="panel-content">
                <div class="table-container">
                    <table class="data-table" id="devicesTable">
                        <thead>
                            <tr>
                                <th>IP Address</th>
                                <th>MAC Address</th>
                                <th>Vendor</th>
                                <th>Network</th>
                                <th>Details & Actions</th>
                            </tr>
                        </thead>
                        <tbody>
                            <!-- Populated by JS -->
                            <tr><td colspan="5" class="text-center p-3">Loading device data...</td></tr>
                        </tbody>
                    </table>
                </div>
            </div>
        </div>

        <!-- Plugin Logs -->
        <div class="dashboard-panel">
            <div class="panel-header" data-bs-toggle="tooltip" title="Real-time logs generated by active plugins.">
                <h2>Plugin Logs</h2>
                <span class="panel-toggle collapsed">▼</span>
            </div>
            <div class="panel-content collapsed">
                <div class="table-container">
                    <table class="data-table" id="pluginLogsTable">
                        <thead>
                            <tr>
                                <th>Plugin</th>
                                <th>Event</th>
                                <th>Timestamp</th>
                            </tr>
                        </thead>
                        <tbody>
                            <!-- Populated by JS -->
                            <tr><td colspan="3" class="text-center p-3">Waiting for plugin logs...</td></tr>
                        </tbody>
                    </table>
                </div>
                <div class="table-actions">
                    <button id="clearLogsButton" class="clear-logs-button btn btn-sm btn-outline-secondary" data-bs-toggle="tooltip" title="Clear the log display (does not delete logs from server).">Clear Log Display</button>
                    <button id="autoScrollToggle" class="auto-scroll-button active btn btn-sm btn-outline-secondary" data-bs-toggle="tooltip" title="Toggle automatic scrolling to the latest log entry.">Auto-scroll: ON</button>
                </div>
            </div>
        </div>

        <!-- Plugin Actions -->
        <div class="dashboard-panel">
            <div class="panel-header" data-bs-toggle="tooltip" title="Global actions provided by plugins.">
                <h2>Available Actions</h2>
                <span class="panel-toggle">▼</span>
            </div>
            <div class="panel-content">
                <div class="action-container" id="pluginActionsContainer">
                    <p class="no-actions-message">No global actions available from plugins.</p>
                    <!-- Populated by JS -->
                </div>
            </div>
        </div>
    </div>

    <!-- Dashboard Controls -->
    <div class="dashboard-controls">
        <button id="syncButton" class="sync-button btn btn-primary" data-bs-toggle="tooltip" title="Manually refresh all dashboard data.">
            <i class="fas fa-sync-alt"></i> Sync Dashboard
        </button>
        <button id="restartServiceButton" class="service-button btn btn-warning" data-bs-toggle="tooltip" title="Restart the core NetFang service.">
            <i class="fas fa-power-off"></i> Restart Netfang Service
        </button>
        <button id="reInitNetfangButton" class="service-button btn btn-danger" data-bs-toggle="tooltip" title="Delete the database and restart the NetFang service.">
            <i class="fas fa-exclamation-triangle"></i> Delete Database and restart
        </button>
        <div id="statusMessage" class="status-message"></div>
    </div>
{% endblock %}

{% block additional_scripts %}
<script>
    // socket is globally available from hidden_structure.html

    // --- Configuration & State ---
    alertify.defaults.notifier.position = 'top-right';
    alertify.defaults.notifier.delay = 5;
    alertify.defaults.transition = "slide";
    alertify.defaults.theme.ok = "btn btn-primary";
    alertify.defaults.theme.cancel = "btn btn-danger";
    alertify.defaults.theme.input = "form-control";

    let previousState = '{{ state }}';
    let currentTypewriterInterval = null;
    let scanCompletedTimeout = null;
    let autoScrollEnabled = true;
    let registeredActions = {}; // { action_id: action_data }
    let networkIdToMac = {};    // { network_id: mac_address }
    let deviceIdToInfo = {};    // { device_id: { ip, mac, network_id } }
    const SYNC_INTERVAL = 30000; // Auto-sync every 30 seconds
    let autoSyncIntervalId = null;

    const stateDescriptions = {
        'WAITING_FOR_NETWORK': 'NetFang is waiting for a network connection. Check physical connection or Wi-Fi settings.',
        'DISCONNECTED': 'Network connection lost. Attempting to reconnect automatically.',
        'RECONNECTING': 'Attempting to re-establish network connection...',
        'CONNECTING': 'Establishing connection to the network...',
        'CONNECTED_KNOWN': 'Connected to a known network. Security baseline established.',
        'CONNECTED_HOME': 'Connected to Home network. Full security features active.',
        'CONNECTED_NEW': 'Connected to an unrecognized network. Enhanced monitoring active.',
        'CONNECTED_BLACKLISTED': 'CRITICAL: Connected to a blacklisted network! Maximum protection measures enabled.',
        'SCANNING_IN_PROGRESS': 'Network scan in progress. Discovering devices and assessing threats...',
        'SCAN_COMPLETED': 'Network scan finished. Analyzing results...',
        'PERFORM_ACTION': 'Executing requested security action...'
        // Add more states as needed
    };

    // --- DOM Element References ---
    const stateElement = document.getElementById("state");
    const scanningIndicator = document.getElementById("scanningIndicator");
    const stateIndicator = document.querySelector(".state-indicator");
    const stateStatusProgress = document.querySelector(".state-status-progress");
    const stateDescription = document.getElementById("stateDescription");
    const dashboardContainer = document.querySelector(".dashboard-container");
    const currentProcessesContainer = document.getElementById('currentProcessesContainer');
    const pluginLogsTableBody = document.getElementById('pluginLogsTable').querySelector('tbody');
    const clearLogsButton = document.getElementById('clearLogsButton');
    const autoScrollToggle = document.getElementById('autoScrollToggle');
    const networksTableBody = document.getElementById('networksTable').querySelector('tbody');
    const devicesTableBody = document.getElementById('devicesTable').querySelector('tbody');
    const pluginActionsContainer = document.getElementById('pluginActionsContainer');
    const syncButton = document.getElementById('syncButton');
    const restartServiceButton = document.getElementById('restartServiceButton');
    const reInitNetfangButton = document.getElementById('reInitNetfangButton');
    const statusMessage = document.getElementById('statusMessage');

    // --- Utility Functions ---
    function formatTimestamp(timestamp) {
        if (!timestamp) return 'N/A';
        try {
            const date = new Date(timestamp);
            // Use locale-sensitive formatting
            return date.toLocaleString(undefined, {
                dateStyle: 'short',
                timeStyle: 'medium'
            });
        } catch (e) {
            console.error("Invalid timestamp format:", timestamp, e);
            return 'Invalid time';
        }
    }

    function showStatusMessage(message, duration = 3000, type = 'info') {
        statusMessage.textContent = message;
        statusMessage.className = `status-message ${type}`; // Add type class for styling
        statusMessage.style.opacity = 1;
        setTimeout(() => {
            statusMessage.style.opacity = 0;
        }, duration);
    }

    // Initialize Bootstrap Tooltips
    function initializeTooltips() {
        const tooltipTriggerList = [].slice.call(document.querySelectorAll('[data-bs-toggle="tooltip"]'));
        tooltipTriggerList.map(function (tooltipTriggerEl) {
            return new bootstrap.Tooltip(tooltipTriggerEl);
        });
    }

    // --- State Management ---
    function typeText(element, text) {
        if (currentTypewriterInterval) clearInterval(currentTypewriterInterval);
        let index = 0;
        element.textContent = ''; // Use textContent for performance
        currentTypewriterInterval = setInterval(() => {
            if (index < text.length) {
                element.textContent += text.charAt(index);
                index++;
            } else {
                clearInterval(currentTypewriterInterval);
                currentTypewriterInterval = null;
            }
        }, 30); // Slightly faster typing
    }

    function updateStateIndicator(state) {
        console.log(`Updating state indicator to: ${state}`);
        // Update classes for visual styling
        stateIndicator.className = `state-indicator state-${state.toLowerCase().replace(/_/g, '-')}`;
        dashboardContainer.className = `dashboard-container dashboard-state-${state.toLowerCase().replace(/_/g, '-')}`;

        // Handle scanning indicator and progress bar
        const isScanning = state === "SCANNING_IN_PROGRESS";
        const isConnecting = state === "CONNECTING" || state === "RECONNECTING";
        scanningIndicator.classList.toggle('active', isScanning || isConnecting);
        stateStatusProgress.style.animation = (isScanning || isConnecting) ? "progressAnim 2s infinite" : "none";
        stateStatusProgress.style.background = ''; // Reset background

        // Clear previous scan completed timeout
        if (scanCompletedTimeout) clearTimeout(scanCompletedTimeout);

        // Dismiss persistent notifications unless it's a critical state
        if (state !== "CONNECTED_BLACKLISTED") {
            alertify.dismissAll(); // Consider being more selective if needed
        }

        // Set progress bar width and specific styles
        let progressWidth = "50%"; // Default
        if (state === "CONNECTED_HOME" || state === "CONNECTED_KNOWN" || state === "SCAN_COMPLETED") {
            progressWidth = "100%";
        } else if (state === "CONNECTED_NEW") {
            progressWidth = "75%";
        } else if (state === "CONNECTED_BLACKLISTED") {
            progressWidth = "100%";
            stateStatusProgress.style.background = "linear-gradient(to right, #dc3545, #f8d7da)"; // Use Bootstrap danger colors
            alertify.error('CRITICAL: Connected to a blacklisted network!', 0);
        } else if (state === "DISCONNECTED" || state === "WAITING_FOR_NETWORK") {
            progressWidth = "10%"; // Lower for disconnected states
            if (previousState !== state) { // Only show warning once on transition
                alertify.warning('Network connection lost.');
            }
        }
        stateStatusProgress.style.width = progressWidth;

        // Handle SCAN_COMPLETED transition
        if (previousState === "SCANNING_IN_PROGRESS" && state === "SCAN_COMPLETED") {
            alertify.success('Network scan completed successfully!');
            // Temporarily show SCAN_COMPLETED, then sync to get the actual connected state
            scanCompletedTimeout = setTimeout(window.syncDashboard, 4000);
        }

        // Update state description and tooltip
        const descriptionText = stateDescriptions[state] || 'Status unknown.';
        stateDescription.textContent = descriptionText;
        stateDescription.setAttribute('data-bs-original-title', descriptionText); // Update tooltip content

        updateButtonStyles(state);
        updateTableStyles(state); // Optional: Style tables based on state

        // Only type text if the state name actually changed
        if (stateElement.textContent !== state) {
            typeText(stateElement, state);
        }

        previousState = state; // Update previous state *after* all updates
    }

    function updateButtonStyles(state) {
        syncButton.disabled = (state === "SCANNING_IN_PROGRESS");
        syncButton.classList.toggle('disabled', syncButton.disabled);

        // Reset restart button
        restartServiceButton.className = 'service-button btn btn-warning'; // Base classes
        restartServiceButton.innerHTML = '<i class="fas fa-power-off"></i> Restart Netfang Service';
        restartServiceButton.disabled = false;

        if (state === "CONNECTED_BLACKLISTED") {
            restartServiceButton.classList.remove('btn-warning');
            restartServiceButton.classList.add('btn-danger'); // More emphasis
            restartServiceButton.innerHTML = '<i class="fas fa-shield-alt"></i> Security Reset';
            restartServiceButton.setAttribute('data-bs-original-title', 'Perform a security reset due to blacklisted network.');
        } else {
             restartServiceButton.setAttribute('data-bs-original-title', 'Restart the core NetFang service.');
        }
        // Potentially disable restart during critical operations?
        // if (state === "PERFORM_ACTION" || state === "SCANNING_IN_PROGRESS") {
        //     restartServiceButton.disabled = true;
        // }
    }

    function updateTableStyles(state) {
        // Optional: Add subtle visual cues to tables based on state
        const tables = document.querySelectorAll('.data-table');
        tables.forEach(table => {
            table.classList.remove('table-state-warning', 'table-state-critical', 'table-state-scanning');
            if (state === "CONNECTED_BLACKLISTED") {
                table.classList.add('table-state-critical');
            } else if (state === "CONNECTED_NEW") {
                 table.classList.add('table-state-warning');
            } else if (state === "SCANNING_IN_PROGRESS") {
                 table.classList.add('table-state-scanning');
            }
        });
        // Add corresponding CSS rules in hidden.css for these classes
        // e.g., .table-state-critical thead { background-color: #f8d7da; }
    }

    // --- Data Handling & UI Updates ---

    function updateDashboardData(data) {
        console.log(`[${new Date().toLocaleTimeString()}] Updating dashboard with data:`, data);

        // Clear previous data mappings
        networkIdToMac = {};
        deviceIdToInfo = {};

        // --- Populate Networks Table ---
        networksTableBody.innerHTML = ''; // Clear placeholder/old data
        if (data.networks && data.networks.length > 0) {
            data.networks.forEach(network => {
                networkIdToMac[network.id] = network.mac_address; // Store mapping

                const row = networksTableBody.insertRow();
                row.className = network.is_blacklisted ? 'table-danger' : (network.is_home ? 'table-success-light' : ''); // Use CSS classes

                const statusText = network.is_home ? 'Home' : (network.is_blacklisted ? 'Blacklisted' : 'Known');
                const statusClass = network.is_home ? 'status-home' : (network.is_blacklisted ? 'status-blacklisted' : 'status-known');

                const actionButtonsHtml = getActionButtonsHtml('network', network.id);

                row.innerHTML = `
                    <td>${network.mac_address || 'N/A'}</td>
                    <td><span class="status-badge ${statusClass}">${statusText}</span></td>
                    <td>${formatTimestamp(network.last_seen)}</td>
                    <td class="actions-cell">${actionButtonsHtml || 'None'}</td>
                `;
            });
        } else {
            networksTableBody.innerHTML = '<tr><td colspan="4" class="text-center p-3">No networks found.</td></tr>';
        }

        // --- Populate Devices Table ---
        devicesTableBody.innerHTML = ''; // Clear placeholder/old data
        if (data.devices && data.devices.length > 0) {
            data.devices.forEach(device => {
                deviceIdToInfo[device.id] = { // Store mapping
                    ip: device.ip_address,
                    mac: device.mac_address,
                    network_id: device.network_id
                };

                const row = devicesTableBody.insertRow();
                // Add classes based on device properties if available (e.g., is_new, has_vulns)
                // row.className = device.is_new ? 'table-info-light' : '';

                const networkInfo = device.network_id && networkIdToMac[device.network_id]
                    ? `<span class="network-link" title="Network ID: ${device.network_id}">${networkIdToMac[device.network_id]}</span>`
                    : 'Unknown';

                // Improved Fingerprint Display
                const hasFingerprint = device.fingerprint && device.fingerprint !== 'None';
                const fingerprintHtml = hasFingerprint ? `
                    <div class="fingerprint-container">
                        <button class="btn btn-sm btn-outline-secondary show-fingerprint" data-bs-toggle="collapse" data-bs-target="#fp-${device.id}">
                            <i class="fas fa-fingerprint"></i>
                        </button>
                        <div class="collapse fingerprint-data" id="fp-${device.id}">
                            <pre>${JSON.stringify(device.fingerprint, null, 2)}</pre>
                        </div>
                    </div>
                ` : '';

                const actionButtonsHtml = getActionButtonsHtml('device', device.id);

                row.innerHTML = `
                    <td>${device.ip_address || 'N/A'}</td>
                    <td>${device.mac_address || 'N/A'}</td>
                    <td>${device.vendor || 'Unknown'}</td>
                    <td>${networkInfo}</td>
                    <td class="actions-cell">${fingerprintHtml} ${actionButtonsHtml || ''}</td>
                `;
            });
        } else {
            devicesTableBody.innerHTML = '<tr><td colspan="5" class="text-center p-3">No devices found.</td></tr>';
        }

        // --- Populate Plugin Logs ---
        // Only do a full refresh if explicitly requested or on initial load
        // Otherwise, rely on the real-time 'plugin_log' event
        if (data.plugin_logs && pluginLogsTableBody.rows.length === 1 && pluginLogsTableBody.rows[0].cells.length > 1) { // Check if it's the placeholder
             pluginLogsTableBody.innerHTML = ''; // Clear placeholder
             data.plugin_logs
                .sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp)) // Sort newest first
                .slice(0, 50) // Limit initial load size
                .forEach(log => addPluginLog(log, false)); // Add without animation initially
        } else if (!data.plugin_logs || data.plugin_logs.length === 0 && pluginLogsTableBody.rows.length === 0) {
             pluginLogsTableBody.innerHTML = '<tr><td colspan="3" class="text-center p-3">No plugin logs available.</td></tr>';
        }


        // --- Update Actions Panel ---
        updateActionsPanel(); // Update global actions

        // --- Final Touches ---
        setupActionButtons(); // Re-bind events for new buttons
        initializeTooltips(); // Re-initialize tooltips for new elements

        showStatusMessage(`Dashboard updated at ${new Date().toLocaleTimeString()}`, 3000, 'success');
    }

    function addPluginLog(log, animate = true) {
        // Clear placeholder if present
        if (pluginLogsTableBody.rows.length === 1 && pluginLogsTableBody.rows[0].cells.length > 1 && pluginLogsTableBody.rows[0].textContent.includes("Waiting")) {
            pluginLogsTableBody.innerHTML = '';
        }

        const row = pluginLogsTableBody.insertRow(0); // Insert at the top
        row.innerHTML = `
            <td>${log.plugin_name || 'System'}</td>
            <td>${log.event || 'Unknown event'}</td>
            <td>${formatTimestamp(log.timestamp)}</td>
        `;

        if (animate) {
            row.classList.add('new-log-entry'); // CSS class for flash animation
            setTimeout(() => row.classList.remove('new-log-entry'), 2000);
        }

        if (autoScrollEnabled) {
            // Scroll the *table container* if it exists and is scrollable
            const container = pluginLogsTableBody.closest('.table-container');
            if (container) {
                container.scrollTop = 0; // Scroll to top since we prepend
            }
        }

        // Limit table size for performance
        const MAX_LOG_ROWS = 500; // Reduced limit
        while (pluginLogsTableBody.rows.length > MAX_LOG_ROWS) {
            pluginLogsTableBody.deleteRow(pluginLogsTableBody.rows.length - 1);
        }
    }

    // --- Action Handling ---
    function getActionButtonsHtml(targetType, targetId) {
        let buttonsHtml = '';
        Object.values(registeredActions)
            .filter(action => action.target_type === targetType)
            .forEach(action => {
                // Check if action applies to this specific target or is generic for the type
                // Assuming target_id=null means it applies to all items of target_type
                // This logic might need adjustment based on backend implementation
                // if (action.target_id === null || action.target_id === String(targetId)) {
                    buttonsHtml += `
                        <button
                            class="plugin-action-button btn btn-sm btn-outline-primary"
                            data-action-id="${action.action_id}"
                            data-target-id="${targetId}"
                            data-plugin-name="${action.plugin_name}"
                            data-action-name="${action.action_name}"
                            data-confirm="${action.requires_confirmation || 'false'}"
                            data-bs-toggle="tooltip"
                            title="${action.description || action.action_name}"
                        >
                            <i class="fas ${action.icon || 'fa-bolt'}"></i> ${action.action_name}
                        </button>
                    `;
                // }
            });
        return buttonsHtml;
    }

    function updateActionsPanel() {
        pluginActionsContainer.innerHTML = ''; // Clear existing
        const systemActions = Object.values(registeredActions).filter(a => a.target_type === 'system');

        if (systemActions.length === 0) {
            pluginActionsContainer.innerHTML = '<p class="no-actions-message">No global actions available from plugins.</p>';
            return;
        }

        // Group by plugin for better organization
        const actionsByPlugin = systemActions.reduce((acc, action) => {
            acc[action.plugin_name] = acc[action.plugin_name] || [];
            acc[action.plugin_name].push(action);
            return acc;
        }, {});

        Object.entries(actionsByPlugin).forEach(([pluginName, actions]) => {
            const groupDiv = document.createElement('div');
            groupDiv.className = 'plugin-action-group mb-3';
            groupDiv.innerHTML = `<h5>${pluginName}</h5>`;
            const buttonsDiv = document.createElement('div');
            buttonsDiv.className = 'action-buttons btn-group flex-wrap'; // Use btn-group for spacing

            actions.forEach(action => {
                buttonsDiv.innerHTML += `
                    <button
                        class="plugin-action-button btn btn-outline-secondary m-1"
                        data-action-id="${action.action_id}"
                        data-target-id="system"
                        data-plugin-name="${action.plugin_name}"
                        data-action-name="${action.action_name}"
                        data-confirm="${action.requires_confirmation || 'false'}"
                        data-bs-toggle="tooltip"
                        title="${action.description || action.action_name}"
                    >
                         <i class="fas ${action.icon || 'fa-cogs'}"></i> ${action.action_name}
                    </button>
                `;
            });
            groupDiv.appendChild(buttonsDiv);
            pluginActionsContainer.appendChild(groupDiv);
        });

        // Re-bind events and tooltips after updating HTML
        setupActionButtons();
        initializeTooltips();
    }

    function setupActionButtons() {
        // Use event delegation on a parent container for dynamically added buttons
        const dashboard = document.querySelector('.dashboard-container');
        if (!dashboard) return;

        // Remove previous listener to avoid duplicates if called multiple times
        dashboard.removeEventListener('click', handleActionButtonClick);
        dashboard.addEventListener('click', handleActionButtonClick);
    }

    async function handleActionButtonClick(event) {
        const button = event.target.closest('.plugin-action-button');
        if (!button) return; // Click wasn't on an action button or its child

        const actionId = button.dataset.actionId;
        const targetId = button.dataset.targetId;
        const pluginName = button.dataset.pluginName;
        const actionName = button.dataset.actionName;
        const requiresConfirm = button.dataset.confirm === 'true';
        const action = registeredActions[actionId];

        if (!action) {
            console.error(`Action ${actionId} not found in registered actions.`);
            alertify.error('Action definition not found.');
            return;
        }

        const executeAction = async () => {
            console.log(`Executing action: ${actionName} (${pluginName}) on target ${targetId}`);
            button.disabled = true;
            button.innerHTML = '<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span> Executing...';

            try {
                const response = await fetch('/plugin/action', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        plugin_name: pluginName,
                        action_id: actionId,
                        target_type: action.target_type,
                        target_id: targetId
                    })
                });

                const data = await response.json();

                if (response.ok && data.status === 'success') {
                    alertify.success(data.message || `${actionName} executed successfully.`);
                    // Optionally trigger a dashboard sync after successful action
                    // setTimeout(window.syncDashboard, 1000);
                } else {
                    alertify.error(data.message || `Failed to execute ${actionName}.`);
                }
            } catch (error) {
                console.error('Error executing action:', error);
                alertify.error(`Network or server error executing action: ${error.message}`);
            } finally {
                // Restore button state
                button.disabled = false;
                 button.innerHTML = `<i class="fas ${action.icon || (action.target_type === 'system' ? 'fa-cogs' : 'fa-bolt')}"></i> ${actionName}`;
            }
        };

        if (requiresConfirm) {
            alertify.confirm(
                'Confirm Action',
                `Are you sure you want to execute "${actionName}" on target "${targetId}"?`,
                executeAction, // On OK
                () => { alertify.message('Action cancelled.'); } // On Cancel
            ).set('labels', {ok:'Execute', cancel:'Cancel'});
        } else {
            await executeAction();
        }
    }


    // --- Process Output Handling ---
    function handleCommandOutput(data) {
        const { process_id, plugin_name, command, output, is_complete } = data;
        let processContainer = document.getElementById(`process-${process_id}`);

        if (!processContainer) {
            processContainer = document.createElement('div');
            processContainer.id = `process-${process_id}`;
            processContainer.className = 'current-process-container card mb-3'; // Use Bootstrap card
            processContainer.innerHTML = `
                <div class="card-header current-process-header d-flex justify-content-between align-items-center">
                    <span>Process: ${command} <small>(${plugin_name})</small></span>
                    <button class="btn-close" aria-label="Close" onclick="closeProcess('${process_id}')"></button>
                </div>
                <div class="card-body">
                    <pre class="current-process-output bg-light p-2" id="output-${process_id}"></pre>
                </div>
            `;
            currentProcessesContainer.appendChild(processContainer);
        }

        const outputContainer = document.getElementById(`output-${process_id}`);
        if (outputContainer) {
            const outputLine = document.createElement('div');
            outputLine.textContent = output;
            outputContainer.appendChild(outputLine);
            outputContainer.scrollTop = outputContainer.scrollHeight; // Auto-scroll

            if (is_complete) {
                const completionLine = document.createElement('div');
                completionLine.className = 'completion-line text-muted mt-2';
                completionLine.textContent = `--- Process completed (${formatTimestamp(new Date())}) ---`;
                outputContainer.appendChild(completionLine);
                // Optionally auto-close completed processes after a delay
                // setTimeout(() => closeProcess(process_id), 10000);
            }
        }
    }

    function handleCurrentProcess(data) {
        // This function might be redundant if handleCommandOutput creates the container
        // Or it could be used to signal the *start* of a process before output arrives
        if (data) {
            const { process_id, plugin_name, command, start_time } = data;
            let processContainer = document.getElementById(`process-${process_id}`);
            if (!processContainer) {
                 // Create container similar to handleCommandOutput if needed
                 console.log(`Process started: ${command} (${plugin_name}) at ${formatTimestamp(start_time)}`);
                 // Potentially add a placeholder until first output arrives
            }
        }
        // If data is null, maybe clear *all* process containers? Or rely on is_complete?
        // if (data === null) {
        //     currentProcessesContainer.innerHTML = ''; // Clears all - maybe too aggressive
        // }
    }

    window.closeProcess = function(processId) { // Make it globally accessible for onclick
        const processContainer = document.getElementById(`process-${processId}`);
        if (processContainer) {
            processContainer.remove();
            alertify.message(`Closed process view ${processId}`);
        }
    }

    // --- Socket.IO Event Listeners ---
    socket.on('connect', () => {
        console.log('Socket.IO: Connected');
        showStatusMessage('Connected to server', 2000, 'success');
        alertify.success('Real-time connection established.');
        window.syncDashboard(); // Sync data on connect/reconnect
        startAutoSync();
    });

    socket.on('connect_error', (error) => {
        console.error('Socket.IO connection error:', error);
        showStatusMessage('Connection error! Trying to reconnect...', 5000, 'error');
        // Use alertify for persistent notification only if not already shown
        if (!document.querySelector('.alertify .ajs-message.ajs-error') || !document.querySelector('.alertify .ajs-message.ajs-error').textContent.includes('Connection error')) {
             alertify.error('Connection error! Trying to reconnect...', 0);
        }
        stopAutoSync();
    });

    socket.on('disconnect', (reason) => {
        console.warn('Socket.IO: Disconnected. Reason:', reason);
        showStatusMessage('Disconnected from server. Attempting to reconnect...', 5000, 'warning');
        alertify.warning('Real-time connection lost. Reconnecting...', 0);
        stopAutoSync();
    });

    socket.on('reconnect', (attemptNumber) => {
        console.log(`Socket.IO: Reconnected after ${attemptNumber} attempts`);
        showStatusMessage('Reconnected to server', 2000, 'success');
        alertify.dismissAll(); // Clear connection errors
        alertify.success('Real-time connection re-established.');
        window.syncDashboard(); // Sync data on reconnect
        startAutoSync();
    });

    socket.on("state_update", (data) => {
        console.log(`[${new Date().toLocaleTimeString()}] State update:`, data);
        if (data.state) {
            updateStateIndicator(data.state);
        }
    });

    socket.on('dashboard_data', (data) => {
        updateDashboardData(data);
        // Stop sync animation if it was running
        syncButton.classList.remove('syncing');
        syncButton.innerHTML = '<i class="fas fa-sync-alt"></i> Sync Dashboard';
    });

    socket.on('plugin_log', (log) => {
        addPluginLog(log);
    });

    socket.on('command_output', (data) => {
        handleCommandOutput(data);
    });

    socket.on('current_process', (data) => {
        handleCurrentProcess(data);
    });

    socket.on('register_action', (action) => {
        console.log(`[${new Date().toLocaleTimeString()}] Action registered:`, action);
        if (action && action.action_id) {
            registeredActions[action.action_id] = action;
            updateActionsPanel(); // Update UI with the new action
            alertify.notify(`New action available: ${action.action_name}`, 'info', 3);
        } else {
            console.error("Invalid action registration data received:", action);
        }
    });

    socket.on('alert_sync', (data) => {
        console.log(`[${new Date().toLocaleTimeString()}] Alert received:`, data);
        const level = data.level ? data.level.toUpperCase() : 'INFO';
        const message = data.message || 'Received an unspecified alert.';
        const duration = (level === 'ERROR' || level === 'CRITICAL') ? 0 : (level === 'WARNING' ? 10 : 5);

        switch (level) {
            case 'CRITICAL':
            case 'ERROR':
                alertify.error(message, duration);
                break;
            case 'WARNING':
                alertify.warning(message, duration);
                break;
            case 'SUCCESS':
                alertify.success(message, duration);
                break;
            case 'INFO':
            default:
                alertify.info(message, duration);
                break;
        }
    });

    // --- Event Handlers ---
    window.syncDashboard = function() {
        if (socket.connected) {
            console.log('Requesting dashboard sync...');
            socket.emit('sync_dashboard');
            showStatusMessage('Syncing dashboard data...', 2000, 'info');
            syncButton.classList.add('syncing'); // Add visual feedback
            syncButton.innerHTML = '<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span> Syncing...';
        } else {
            alertify.error('Cannot sync: Not connected to server.');
        }
    };

    clearLogsButton.addEventListener('click', () => {
        pluginLogsTableBody.innerHTML = '<tr><td colspan="3" class="text-center p-3">Log display cleared.</td></tr>';
        alertify.message('Log display cleared');
    });

    autoScrollToggle.addEventListener('click', () => {
        autoScrollEnabled = !autoScrollEnabled;
        autoScrollToggle.textContent = autoScrollEnabled ? 'Auto-scroll: ON' : 'Auto-scroll: OFF';
        autoScrollToggle.classList.toggle('active', autoScrollEnabled);
        alertify.message(`Auto-scroll ${autoScrollEnabled ? 'enabled' : 'disabled'}`);
    });

    syncButton.addEventListener('click', window.syncDashboard);

    restartServiceButton.addEventListener('click', () => {
        const isBlacklisted = previousState === "CONNECTED_BLACKLISTED";
        const confirmMessage = isBlacklisted
            ? 'This will perform a security reset due to the blacklisted network. Are you sure?'
            : 'Are you sure you want to restart the Netfang service? This may interrupt monitoring briefly.';

        alertify.confirm(
            isBlacklisted ? 'Confirm Security Reset' : 'Confirm Service Restart',
            confirmMessage,
            async () => { // On OK
                showStatusMessage('Initiating restart...', 3000, 'info');
                restartServiceButton.disabled = true;
                restartServiceButton.innerHTML = '<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span> Restarting...';

                try {
                    const response = await fetch('/update', { // Assuming /update triggers restart
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' }
                        // Add body if needed by the endpoint
                    });
                    const data = await response.json();

                    if (response.ok && data.status === 'success') {
                        showStatusMessage(data.message || 'Service restart initiated.', 5000, 'success');
                        alertify.success(data.message || 'Service restart initiated.');
                        // State will likely change via socket update, no need to force UI change here
                    } else {
                        showStatusMessage(data.message || 'Failed to initiate restart.', 5000, 'error');
                        alertify.error(data.message || 'Failed to initiate restart.');
                        restartServiceButton.disabled = false; // Re-enable on failure
                        updateButtonStyles(previousState); // Restore original button text/style
                    }
                } catch (error) {
                    console.error("Error restarting service:", error);
                    showStatusMessage(`Error: ${error.message}`, 5000, 'error');
                    alertify.error(`Error initiating restart: ${error.message}`);
                    restartServiceButton.disabled = false; // Re-enable on failure
                    updateButtonStyles(previousState); // Restore original button text/style
                }
                // Button state will be fully restored by state updates or if it fails
            },
            () => { // On Cancel
                alertify.message('Restart cancelled.');
            }
        ).set('labels', {ok:'Confirm', cancel:'Cancel'});
    });

    // Add event listener for reInitNetfangButton
    reInitNetfangButton.addEventListener('click', () => {
        // Show a confirmation dialog with warning about data loss
        alertify.confirm(
            'Confirm Database Reset',
            'WARNING: This will delete the entire NetFang database and restart the service. All network history, device information, and configuration will be lost. Are you sure you want to proceed?',
            async () => { // On Confirm
                showStatusMessage('Resetting NetFang database...', 3000, 'info');
                reInitNetfangButton.disabled = true;
                reInitNetfangButton.innerHTML = '<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span> Resetting...';

                try {
                    const response = await fetch('/reinit', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' }
                    });
                    const data = await response.json();

                    if (response.ok && (data.status === 'success' || data.status === 'partial')) {
                        showStatusMessage(data.message || 'NetFang database reset successfully.', 5000, 'success');
                        alertify.success(data.message || 'NetFang database reset successfully.');
                        
                        // Force sync dashboard after a delay to get fresh data
                        setTimeout(window.syncDashboard, 3000);
                    } else {
                        showStatusMessage(data.message || 'Failed to reset NetFang database.', 5000, 'error');
                        alertify.error(data.message || 'Failed to reset NetFang database.');
                        reInitNetfangButton.disabled = false;
                        reInitNetfangButton.innerHTML = '<i class="fas fa-exclamation-triangle"></i> Delete Database and restart';
                    }
                } catch (error) {
                    console.error("Error resetting NetFang:", error);
                    showStatusMessage(`Error: ${error.message}`, 5000, 'error');
                    alertify.error(`Error resetting NetFang: ${error.message}`);
                    reInitNetfangButton.disabled = false;
                    reInitNetfangButton.innerHTML = '<i class="fas fa-exclamation-triangle"></i> Delete Database and restart';
                }
            },
            () => { // On Cancel
                alertify.message('Database reset cancelled.');
            }
        ).set('labels', {ok:'Reset Database', cancel:'Cancel'})
        .set('closable', false); // Prevent clicking outside to dismiss
    });

    // Panel Collapse Toggle (Using Bootstrap's built-in JS via data attributes is often easier)
    // If manual control is needed:
    document.querySelectorAll('.panel-header').forEach(header => {
        header.addEventListener('click', (e) => {
            // Prevent toggling if click is on a button inside the header
            if (e.target.closest('button')) return;

            const toggle = header.querySelector('.panel-toggle');
            const content = header.nextElementSibling;
            if (toggle && content) {
                toggle.classList.toggle('collapsed');
                content.classList.toggle('collapsed'); // Assumes CSS handles visibility
            }
        });
    });

    // --- Initialization ---
    function startAutoSync() {
        if (autoSyncIntervalId) clearInterval(autoSyncIntervalId); // Clear existing interval
        autoSyncIntervalId = setInterval(window.syncDashboard, SYNC_INTERVAL);
        console.log(`Auto-sync started every ${SYNC_INTERVAL / 1000} seconds.`);
    }

    function stopAutoSync() {
        if (autoSyncIntervalId) {
            clearInterval(autoSyncIntervalId);
            autoSyncIntervalId = null;
            console.log('Auto-sync stopped.');
        }
    }

    document.addEventListener('DOMContentLoaded', () => {
        console.log('DOM fully loaded and parsed');
        updateStateIndicator(previousState); // Set initial state visuals
        initializeTooltips(); // Initialize any static tooltips
        setupActionButtons(); // Setup initial action button listeners

        if (socket.connected) {
            window.syncDashboard(); // Get initial data if already connected
            startAutoSync();
        } else {
            console.log('Socket not connected on DOMContentLoaded, waiting for connect event.');
            // Show a loading state or message?
            networksTableBody.innerHTML = '<tr><td colspan="4" class="text-center p-3">Connecting to server...</td></tr>';
            devicesTableBody.innerHTML = '<tr><td colspan="5" class="text-center p-3">Connecting to server...</td></tr>';
        }
    });

</script>
{% endblock %}
