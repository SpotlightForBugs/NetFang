{% extends "hidden/hidden_structure.html" %}

{% block title %}NetFang Secured Router - Dashboard{% endblock %}

{% block header_title %}NetFang Secured Router - {{ hostname }}{% endblock %}

{% block main_content %}
    <!-- Status Bar - Now uses glass-panel style -->
    <div class="state-indicator state-{{ state | lower | replace('_', '-') }} glass-panel mb-4">
        <div class="status-header">
            <h2><i class="fas fa-shield-alt"></i> NetFang Status</h2>
            <span id="state" class="status-badge">{{ state }}</span>
        </div>
        <div class="status-progress">
            <div id="scanningIndicator" class="scanning-indicator">
                <div class="scanning-pulse"></div>
                <span>Scanning network...</span>
            </div>
            <div class="state-status-bar">
                <div class="state-status-progress"></div>
            </div>
        </div>
        <div id="stateDescription" class="state-description" data-bs-toggle="tooltip" data-bs-placement="bottom" title="Current operational status and context.">
            <!-- Description populated by JS -->
        </div>
    </div>

    <!-- Main Dashboard Container - Uses the layout from the base template -->
    <div class="dashboard-layout">
        <!-- Left Column - Core Information -->
        <div class="dashboard-column">
            <!-- Networks Information - Now uses glass-panel style -->
            <div class="dashboard-panel glass-panel">
                <div class="panel-header" data-bs-toggle="tooltip" title="Detected networks and their status.">
                    <h3><i class="fas fa-network-wired"></i> Networks</h3>
                    <span class="panel-toggle">▼</span>
                </div>
                <div class="panel-content">
                    <div class="table-container">
                        <table class="data-table" id="networksTable">
                            <thead>
                                <tr>
                                    <th>MAC Address</th>
                                    <th>Status</th>
                                    <th>Last Seen</th>
                                    <th>Actions</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr><td colspan="4" class="text-center p-3">Loading network data...</td></tr>
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>

            <!-- Devices Information - Now uses glass-panel style -->
            <div class="dashboard-panel glass-panel">
                <div class="panel-header" data-bs-toggle="tooltip" title="Devices detected on the current or known networks.">
                    <h3><i class="fas fa-laptop"></i> Devices</h3>
                    <span class="panel-toggle">▼</span>
                </div>
                <div class="panel-content">
                    <div class="table-container">
                        <table class="data-table" id="devicesTable">
                            <thead>
                                <tr>
                                    <th>IP Address</th>
                                    <th>MAC Address</th>
                                    <th>Vendor</th>
                                    <th>Network</th>
                                    <th>Details & Actions</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr><td colspan="5" class="text-center p-3">Loading device data...</td></tr>
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>
        </div>

        <!-- Right Column - Actions and Logs -->
        <div class="dashboard-column">
            <!-- Current Processes Display -->
            <div id="currentProcessesContainer" class="current-processes-container">
                <!-- Dynamically added process boxes will use glass-panel -->
            </div>

            <!-- Plugin Actions - Now uses glass-panel style -->
            <div class="dashboard-panel glass-panel">
                <div class="panel-header" data-bs-toggle="tooltip" title="Global actions provided by plugins.">
                    <h3><i class="fas fa-bolt"></i> Available Actions</h3>
                    <span class="panel-toggle">▼</span>
                </div>
                <div class="panel-content">
                    <div class="action-container" id="pluginActionsContainer">
                        <p class="no-actions-message">No global actions available from plugins.</p>
                    </div>
                </div>
            </div>

            <!-- Plugin Logs - Now uses glass-panel style -->
            <div class="dashboard-panel glass-panel">
                <div class="panel-header" data-bs-toggle="tooltip" title="Real-time logs generated by active plugins.">
                    <h3><i class="fas fa-list-alt"></i> Plugin Logs</h3>
                    <span class="panel-toggle collapsed">▼</span>
                </div>
                <div class="panel-content collapsed">
                    <div class="table-container">
                        <table class="data-table" id="pluginLogsTable">
                            <thead>
                                <tr>
                                    <th>Plugin</th>
                                    <th>Event</th>
                                    <th>Timestamp</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr><td colspan="3" class="text-center p-3">Waiting for plugin logs...</td></tr>
                            </tbody>
                        </table>
                    </div>
                    <div class="table-actions">
                        <button id="clearLogsButton" class="btn btn-outline-secondary btn-sm" data-bs-toggle="tooltip" title="Clear the log display (does not delete logs from server).">
                            <i class="fas fa-eraser"></i> Clear Logs
                        </button>
                        <button id="autoScrollToggle" class="btn btn-outline-secondary btn-sm active" data-bs-toggle="tooltip" title="Toggle automatic scrolling to the latest log entry.">
                            <i class="fas fa-scroll"></i> Auto-scroll: ON
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Dashboard Controls - Now uses glass-panel style -->
    <div class="dashboard-controls glass-panel mt-4">
        <div class="control-buttons">
            <button id="syncButton" class="btn btn-primary" data-bs-toggle="tooltip" title="Manually refresh all dashboard data.">
                <i class="fas fa-sync-alt"></i> Sync Dashboard
            </button>
            <button id="restartServiceButton" class="btn btn-warning" data-bs-toggle="tooltip" title="Restart the core NetFang service.">
                <i class="fas fa-power-off"></i> Restart Netfang Service
            </button>
            <button id="reInitNetfangButton" class="btn btn-danger" data-bs-toggle="tooltip" title="Delete the database and restart the NetFang service.">
                <i class="fas fa-exclamation-triangle"></i> Delete Database and Restart
            </button>
        </div>
        <div id="statusMessage" class="status-message"></div>
    </div>
{% endblock %}

{% block additional_scripts %}
<script>
    // socket is globally available from hidden_structure.html

    // --- Configuration & State ---
    alertify.defaults.notifier.position = 'top-right';
    alertify.defaults.notifier.delay = 5;
    alertify.defaults.transition = "slide";
    alertify.defaults.theme.ok = "btn btn-primary";
    alertify.defaults.theme.cancel = "btn btn-danger";
    alertify.defaults.theme.input = "form-control";

    let previousState = '{{ state }}';
    let currentTypewriterInterval = null;
    let scanCompletedTimeout = null;
    let autoScrollEnabled = true;
    let registeredActions = {}; // { action_id: action_data }
    let networkIdToMac = {};    // { network_id: mac_address }
    let deviceIdToInfo = {};    // { device_id: { ip, mac, network_id } }
    const SYNC_INTERVAL = 30000; // Auto-sync every 30 seconds
    let autoSyncIntervalId = null;

    const stateDescriptions = {
        'WAITING_FOR_NETWORK': 'NetFang is waiting for a network connection. Check physical connection or Wi-Fi settings.',
        'DISCONNECTED': 'Network connection lost. Attempting to reconnect automatically.',
        'RECONNECTING': 'Attempting to re-establish network connection...',
        'CONNECTING': 'Establishing connection to the network...',
        'CONNECTED_KNOWN': 'Connected to a known network. Security baseline established.',
        'CONNECTED_HOME': 'Connected to Home network. Full security features active.',
        'CONNECTED_NEW': 'Connected to an unrecognized network. Enhanced monitoring active.',
        'CONNECTED_BLACKLISTED': 'CRITICAL: Connected to a blacklisted network! Maximum protection measures enabled.',
        'SCANNING_IN_PROGRESS': 'Network scan in progress. Discovering devices and assessing threats...',
        'SCAN_COMPLETED': 'Network scan finished. Analyzing results...',
        'PERFORM_ACTION': 'Executing requested security action...'
    };

    // --- DOM Element References ---
    const stateElement = document.getElementById("state");
    const scanningIndicator = document.getElementById("scanningIndicator");
    const stateIndicator = document.querySelector(".state-indicator");
    const stateStatusProgress = document.querySelector(".state-status-progress");
    const stateDescription = document.getElementById("stateDescription");
    // Note: dashboardContainer reference removed as layout is now handled by base template
    const currentProcessesContainer = document.getElementById('currentProcessesContainer');
    const pluginLogsTableBody = document.getElementById('pluginLogsTable').querySelector('tbody');
    const clearLogsButton = document.getElementById('clearLogsButton');
    const autoScrollToggle = document.getElementById('autoScrollToggle');
    const networksTableBody = document.getElementById('networksTable').querySelector('tbody');
    const devicesTableBody = document.getElementById('devicesTable').querySelector('tbody');
    const pluginActionsContainer = document.getElementById('pluginActionsContainer');
    const syncButton = document.getElementById('syncButton');
    const restartServiceButton = document.getElementById('restartServiceButton');
    const reInitNetfangButton = document.getElementById('reInitNetfangButton');
    const statusMessage = document.getElementById('statusMessage');

    // --- Utility Functions ---
    function formatTimestamp(timestamp) {
        if (!timestamp) return 'N/A';
        try {
            const date = new Date(timestamp);
            return date.toLocaleString(undefined, {
                dateStyle: 'short',
                timeStyle: 'medium'
            });
        } catch (e) {
            console.error("Invalid timestamp format:", timestamp, e);
            return 'Invalid time';
        }
    }

    function showStatusMessage(message, duration = 3000, type = 'info') {
        statusMessage.textContent = message;
        statusMessage.className = `status-message ${type}`;
        statusMessage.style.opacity = 1;
        setTimeout(() => {
            statusMessage.style.opacity = 0;
        }, duration);
    }

    // Initialize Bootstrap Tooltips
    function initializeTooltips() {
        // Dispose existing tooltips first to prevent duplicates
        const existingTooltips = bootstrap.Tooltip.getInstance(document.body);
        if (existingTooltips) {
            existingTooltips.dispose();
        }
        const tooltipTriggerList = [].slice.call(document.querySelectorAll('[data-bs-toggle="tooltip"]'));
        tooltipTriggerList.map(function (tooltipTriggerEl) {
            // Ensure tooltips are re-initialized correctly
            return new bootstrap.Tooltip(tooltipTriggerEl, {
                trigger: 'hover' // Ensure hover trigger
            });
        });
    }


    // --- State Management ---
    function typeText(element, text) {
        if (currentTypewriterInterval) clearInterval(currentTypewriterInterval);
        let index = 0;
        element.textContent = '';
        currentTypewriterInterval = setInterval(() => {
            if (index < text.length) {
                element.textContent += text.charAt(index);
                index++;
            } else {
                clearInterval(currentTypewriterInterval);
                currentTypewriterInterval = null;
            }
        }, 30);
    }

    function updateStateIndicator(state) {
        console.log(`Updating state indicator to: ${state}`);
        // Update classes for visual styling
        stateIndicator.className = `state-indicator state-${state.toLowerCase().replace(/_/g, '-')} glass-panel mb-4`; // Keep glass-panel

        // Handle scanning indicator and progress bar
        const isScanning = state === "SCANNING_IN_PROGRESS";
        const isConnecting = state === "CONNECTING" || state === "RECONNECTING";
        scanningIndicator.classList.toggle('active', isScanning || isConnecting);
        stateStatusProgress.style.animation = (isScanning || isConnecting) ? "progressAnim 2s infinite" : "none";
        stateStatusProgress.style.background = '';

        // Clear previous scan completed timeout
        if (scanCompletedTimeout) clearTimeout(scanCompletedTimeout);

        // Dismiss persistent alertify notifications unless it's a critical state
        // Note: The main alert panel is handled separately in the base template
        if (state !== "CONNECTED_BLACKLISTED") {
            alertify.dismissAll();
        }

        // Set progress bar width and specific styles
        let progressWidth = "50%";
        if (state === "CONNECTED_HOME" || state === "CONNECTED_KNOWN" || state === "SCAN_COMPLETED") {
            progressWidth = "100%";
        } else if (state === "CONNECTED_NEW") {
            progressWidth = "75%";
        } else if (state === "CONNECTED_BLACKLISTED") {
            progressWidth = "100%";
            stateStatusProgress.style.background = "linear-gradient(to right, #dc3545, #f8d7da)";
            // Use alertify for immediate, non-dismissible critical feedback here
            alertify.error('CRITICAL: Connected to a blacklisted network!', 0);
        } else if (state === "DISCONNECTED" || state === "WAITING_FOR_NETWORK") {
            progressWidth = "10%";
            if (previousState !== state) {
                // Use alertify for transient warning popup
                alertify.warning('Network connection lost.');
            }
        }
        stateStatusProgress.style.width = progressWidth;

        // Handle SCAN_COMPLETED transition
        if (previousState === "SCANNING_IN_PROGRESS" && state === "SCAN_COMPLETED") {
            // Use alertify for transient success popup
            alertify.success('Network scan completed successfully!');
            scanCompletedTimeout = setTimeout(window.syncDashboard, 4000);
        }

        // Update state description and tooltip
        const descriptionText = stateDescriptions[state] || 'Status unknown.';
        stateDescription.textContent = descriptionText;
        stateDescription.setAttribute('data-bs-original-title', descriptionText);

        updateButtonStyles(state);

        // Only type text if the state name actually changed
        if (stateElement.textContent !== state) {
            typeText(stateElement, state);
        }

        previousState = state;
    }

    function updateButtonStyles(state) {
        syncButton.disabled = (state === "SCANNING_IN_PROGRESS");
        syncButton.classList.toggle('disabled', syncButton.disabled);

        // Reset restart button
        restartServiceButton.className = 'btn btn-warning';
        restartServiceButton.innerHTML = '<i class="fas fa-power-off"></i> Restart Netfang Service';
        restartServiceButton.disabled = false;

        if (state === "CONNECTED_BLACKLISTED") {
            restartServiceButton.classList.remove('btn-warning');
            restartServiceButton.classList.add('btn-danger');
            restartServiceButton.innerHTML = '<i class="fas fa-shield-alt"></i> Security Reset';
            restartServiceButton.setAttribute('data-bs-original-title', 'Perform a security reset due to blacklisted network.');
        } else {
             restartServiceButton.setAttribute('data-bs-original-title', 'Restart the core NetFang service.');
        }
    }

    // --- Data Handling & UI Updates ---
    function updateDashboardData(data) {
        console.log(`[${new Date().toLocaleTimeString()}] Updating dashboard with data:`, data);

        // Clear previous data mappings
        networkIdToMac = {};
        deviceIdToInfo = {};

        // --- Populate Networks Table ---
        networksTableBody.innerHTML = '';
        if (data.networks && data.networks.length > 0) {
            data.networks.forEach(network => {
                networkIdToMac[network.id] = network.mac_address;

                const row = networksTableBody.insertRow();
                row.className = network.is_blacklisted ? 'table-danger' : (network.is_home ? 'table-success-light' : '');

                const statusText = network.is_home ? 'Home' : (network.is_blacklisted ? 'Blacklisted' : 'Known');
                const statusClass = network.is_home ? 'status-home' : (network.is_blacklisted ? 'status-blacklisted' : 'status-known');

                const actionButtonsHtml = getActionButtonsHtml('network', network.id);

                row.innerHTML = `
                    <td><span class="mac-address">${network.mac_address || 'N/A'}</span></td>
                    <td><span class="status-badge ${statusClass}">${statusText}</span></td>
                    <td>${formatTimestamp(network.last_seen)}</td>
                    <td class="actions-cell">${actionButtonsHtml || 'None'}</td>
                `;
            });
        } else {
            networksTableBody.innerHTML = '<tr><td colspan="4" class="text-center p-3">No networks found.</td></tr>';
        }

        // --- Populate Devices Table ---
        devicesTableBody.innerHTML = '';
        if (data.devices && data.devices.length > 0) {
            data.devices.forEach(device => {
                deviceIdToInfo[device.id] = {
                    ip: device.ip_address,
                    mac: device.mac_address,
                    network_id: device.network_id
                };

                const row = devicesTableBody.insertRow();

                const networkInfo = device.network_id && networkIdToMac[device.network_id]
                    ? `<span class="network-link" title="Network ID: ${device.network_id}">${networkIdToMac[device.network_id]}</span>`
                    : 'Unknown';

                const hasFingerprint = device.fingerprint && device.fingerprint !== 'None';
                const fingerprintHtml = hasFingerprint ? `
                    <div class="fingerprint-container">
                        <button class="btn btn-sm btn-outline-secondary show-fingerprint" data-bs-toggle="collapse" data-bs-target="#fp-${device.id}">
                            <i class="fas fa-fingerprint"></i>
                        </button>
                        <div class="collapse fingerprint-data" id="fp-${device.id}">
                            <pre>${JSON.stringify(device.fingerprint, null, 2)}</pre>
                        </div>
                    </div>
                ` : '';

                const actionButtonsHtml = getActionButtonsHtml('device', device.id);

                row.innerHTML = `
                    <td><span class="ip-address">${device.ip_address || 'N/A'}</span></td>
                    <td><span class="mac-address">${device.mac_address || 'N/A'}</span></td>
                    <td>${device.vendor || 'Unknown'}</td>
                    <td>${networkInfo}</td>
                    <td class="actions-cell">${fingerprintHtml} ${actionButtonsHtml || ''}</td>
                `;
            });
        } else {
            devicesTableBody.innerHTML = '<tr><td colspan="5" class="text-center p-3">No devices found.</td></tr>';
        }

        // --- Populate Plugin Logs ---
        if (data.plugin_logs && pluginLogsTableBody.rows.length === 1 && pluginLogsTableBody.rows[0].cells.length > 1 && pluginLogsTableBody.rows[0].textContent.includes("Waiting")) {
             pluginLogsTableBody.innerHTML = '';
             data.plugin_logs
                .sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp))
                .slice(0, 50)
                .forEach(log => addPluginLog(log, false));
        } else if (!data.plugin_logs || data.plugin_logs.length === 0 && pluginLogsTableBody.rows.length === 0) {
             pluginLogsTableBody.innerHTML = '<tr><td colspan="3" class="text-center p-3">No plugin logs available.</td></tr>';
        }

        // --- Update Actions Panel ---
        updateActionsPanel();

        // --- Final Touches ---
        setupActionButtons();
        initializeTooltips(); // Re-initialize tooltips for new/updated elements

        showStatusMessage(`Dashboard updated at ${new Date().toLocaleTimeString()}`, 3000, 'success');
    }

    function addPluginLog(log, animate = true) {
        // Clear placeholder if present
        if (pluginLogsTableBody.rows.length === 1 && pluginLogsTableBody.rows[0].cells.length > 1 && pluginLogsTableBody.rows[0].textContent.includes("Waiting")) {
            pluginLogsTableBody.innerHTML = '';
        }

        const row = pluginLogsTableBody.insertRow(0);
        row.innerHTML = `
            <td>${log.plugin_name || 'System'}</td>
            <td>${log.event || 'Unknown event'}</td>
            <td>${formatTimestamp(log.timestamp)}</td>
        `;

        if (animate) {
            row.classList.add('new-log-entry');
            setTimeout(() => row.classList.remove('new-log-entry'), 2000);
        }

        if (autoScrollEnabled) {
            const container = pluginLogsTableBody.closest('.table-container');
            if (container) {
                container.scrollTop = 0;
            }
        }

        // Limit table size for performance
        const MAX_LOG_ROWS = 500;
        while (pluginLogsTableBody.rows.length > MAX_LOG_ROWS) {
            pluginLogsTableBody.deleteRow(pluginLogsTableBody.rows.length - 1);
        }
    }

    // --- Action Handling ---
    function getActionButtonsHtml(targetType, targetId) {
        let buttonsHtml = '';
        Object.values(registeredActions)
            .filter(action => action.target_type === targetType)
            .forEach(action => {
                buttonsHtml += `
                    <button
                        class="plugin-action-button btn btn-sm btn-outline-primary m-1"
                        data-action-id="${action.action_id}"
                        data-target-id="${targetId}"
                        data-plugin-name="${action.plugin_name}"
                        data-action-name="${action.action_name}"
                        data-confirm="${action.requires_confirmation || 'false'}"
                        data-bs-toggle="tooltip"
                        title="${action.description || action.action_name}"
                    >
                        <i class="fas ${action.icon || 'fa-bolt'}"></i> ${action.action_name}
                    </button>
                `;
            });
        return buttonsHtml;
    }

    function updateActionsPanel() {
        pluginActionsContainer.innerHTML = '';
        const systemActions = Object.values(registeredActions).filter(a => a.target_type === 'system');

        if (systemActions.length === 0) {
            pluginActionsContainer.innerHTML = '<p class="no-actions-message">No global actions available from plugins.</p>';
            return;
        }

        // Group by plugin for better organization
        const actionsByPlugin = systemActions.reduce((acc, action) => {
            acc[action.plugin_name] = acc[action.plugin_name] || [];
            acc[action.plugin_name].push(action);
            return acc;
        }, {});

        Object.entries(actionsByPlugin).forEach(([pluginName, actions]) => {
            const groupDiv = document.createElement('div');
            groupDiv.className = 'plugin-action-group mb-3';
            groupDiv.innerHTML = `<h5>${pluginName}</h5>`;
            const buttonsDiv = document.createElement('div');
            buttonsDiv.className = 'action-buttons'; // Removed btn-group, added m-1 to buttons

            actions.forEach(action => {
                buttonsDiv.innerHTML += `
                    <button
                        class="plugin-action-button btn btn-outline-secondary m-1"
                        data-action-id="${action.action_id}"
                        data-target-id="system"
                        data-plugin-name="${action.plugin_name}"
                        data-action-name="${action.action_name}"
                        data-confirm="${action.requires_confirmation || 'false'}"
                        data-bs-toggle="tooltip"
                        title="${action.description || action.action_name}"
                    >
                         <i class="fas ${action.icon || 'fa-cogs'}"></i> ${action.action_name}
                    </button>
                `;
            });
            groupDiv.appendChild(buttonsDiv);
            pluginActionsContainer.appendChild(groupDiv);
        });

        setupActionButtons();
        initializeTooltips();
    }

    function setupActionButtons() {
        // Use event delegation on a parent container that exists on load
        const mainContent = document.querySelector('main'); // Or a more specific container if available
        if (!mainContent) return;

        // Remove previous listener to avoid duplicates if called multiple times
        mainContent.removeEventListener('click', handleActionButtonClick);
        mainContent.addEventListener('click', handleActionButtonClick);
    }

    async function handleActionButtonClick(event) {
        const button = event.target.closest('.plugin-action-button');
        if (!button) return;

        const actionId = button.dataset.actionId;
        const targetId = button.dataset.targetId;
        const pluginName = button.dataset.pluginName;
        const actionName = button.dataset.actionName;
        const requiresConfirm = button.dataset.confirm === 'true';
        const action = registeredActions[actionId];

        if (!action) {
            console.error(`Action ${actionId} not found in registered actions.`);
            alertify.error('Action definition not found.');
            return;
        }

        const executeAction = async () => {
            console.log(`Executing action: ${actionName} (${pluginName}) on target ${targetId}`);
            button.disabled = true;
            button.innerHTML = '<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span> Executing...';

            try {
                const response = await fetch('/plugin/action', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        plugin_name: pluginName,
                        action_id: actionId,
                        target_type: action.target_type,
                        target_id: targetId
                    })
                });

                const data = await response.json();

                if (response.ok && data.status === 'success') {
                    alertify.success(data.message || `${actionName} executed successfully.`);
                } else {
                    alertify.error(data.message || `Failed to execute ${actionName}.`);
                }
            } catch (error) {
                console.error('Error executing action:', error);
                alertify.error(`Network or server error executing action: ${error.message}`);
            } finally {
                button.disabled = false;
                button.innerHTML = `<i class="fas ${action.icon || (action.target_type === 'system' ? 'fa-cogs' : 'fa-bolt')}"></i> ${actionName}`;
            }
        };

        if (requiresConfirm) {
            alertify.confirm(
                'Confirm Action',
                `Are you sure you want to execute "${actionName}" on target "${targetId}"?`,
                executeAction,
                () => { alertify.message('Action cancelled.'); }
            ).set('labels', {ok:'Execute', cancel:'Cancel'});
        } else {
            await executeAction();
        }
    }

    // --- Process Output Handling ---
    function handleCommandOutput(data) {
        const { process_id, plugin_name, command, output, is_complete } = data;
        let processContainer = document.getElementById(`process-${process_id}`);

        if (!processContainer) {
            processContainer = document.createElement('div');
            processContainer.id = `process-${process_id}`;
            // Apply glass-panel style and consistent structure
            processContainer.className = 'current-process-container glass-panel mb-3';
            processContainer.innerHTML = `
                <div class="process-header">
                    <div class="process-title">
                        <i class="fas fa-terminal"></i> ${command}
                        <span class="plugin-badge">${plugin_name}</span>
                    </div>
                    <button class="btn-close" aria-label="Close" onclick="closeProcess('${process_id}')"></button>
                </div>
                <div class="process-body">
                    <pre class="process-output" id="output-${process_id}"></pre>
                </div>
            `;
            // Prepend to keep newest at the top, similar to logs
            currentProcessesContainer.prepend(processContainer);
        }

        const outputContainer = document.getElementById(`output-${process_id}`);
        if (outputContainer) {
            const outputLine = document.createElement('div');
            outputLine.textContent = output;
            outputContainer.appendChild(outputLine);
            outputContainer.scrollTop = outputContainer.scrollHeight;

            if (is_complete) {
                const completionLine = document.createElement('div');
                completionLine.className = 'completion-line';
                completionLine.textContent = `--- Process completed (${formatTimestamp(new Date())}) ---`;
                outputContainer.appendChild(completionLine);
                processContainer.classList.add('process-completed');
            }
        }
    }

    function handleCurrentProcess(data) {
        // This function might signal the start, but handleCommandOutput creates the UI
        if (data) {
            const { process_id, plugin_name, command, start_time } = data;
            let processContainer = document.getElementById(`process-${process_id}`);
            if (!processContainer) {
                console.log(`Process started: ${command} (${plugin_name}) at ${formatTimestamp(start_time)}`);
                // Optionally add a placeholder here if needed before first output
            }
        }
    }

    // Updated closeProcess function with animation
    window.closeProcess = function(processId) {
        const processContainer = document.getElementById(`process-${processId}`);
        if (processContainer) {
            processContainer.classList.add('process-closing'); // Add class for animation
            setTimeout(() => {
                processContainer.remove();
                alertify.message(`Closed process view ${processId}`);
            }, 300); // Match CSS transition duration
        }
    }

    // --- Socket.IO Event Listeners ---
    // Note: 'connect', 'disconnect', 'connect_error', 'reconnecting' are primarily handled
    // by the base template for the global connection badge.
    // These handlers provide additional local feedback (console, status message, alertify popups).

    socket.on('connect', () => {
        console.log('Socket.IO (Dashboard): Connected');
        showStatusMessage('Connected to server', 2000, 'success');
        // Use alertify for transient success popup
        alertify.success('Real-time connection established.');
        window.syncDashboard();
        startAutoSync();
    });

    socket.on('connect_error', (error) => {
        console.error('Socket.IO (Dashboard) connection error:', error);
        showStatusMessage('Connection error! Trying to reconnect...', 5000, 'error');
        // Use alertify for transient error popup
        if (!document.querySelector('.alertify .ajs-message.ajs-error') || !document.querySelector('.alertify .ajs-message.ajs-error').textContent.includes('Connection error')) {
             alertify.error('Connection error! Trying to reconnect...', 0); // Persistent popup for error
        }
        stopAutoSync();
    });

    socket.on('disconnect', (reason) => {
        console.warn('Socket.IO (Dashboard): Disconnected. Reason:', reason);
        showStatusMessage('Disconnected from server. Attempting to reconnect...', 5000, 'warning');
        // Use alertify for transient warning popup
        alertify.warning('Real-time connection lost. Reconnecting...', 0); // Persistent popup
        stopAutoSync();
    });

    socket.on('reconnect', (attemptNumber) => {
        console.log(`Socket.IO (Dashboard): Reconnected after ${attemptNumber} attempts`);
        showStatusMessage('Reconnected to server', 2000, 'success');
        alertify.dismissAll(); // Clear connection errors
        // Use alertify for transient success popup
        alertify.success('Real-time connection re-established.');
        window.syncDashboard();
        startAutoSync();
    });

    // Added handler for consistency with base template states
    socket.on('reconnecting', (attemptNumber) => {
        console.log(`Socket.IO (Dashboard): Attempting reconnect ${attemptNumber}`);
        showStatusMessage('Attempting to reconnect...', 3000, 'warning');
        // Base template handles the visual indicator change
    });


    socket.on("state_update", (data) => {
        console.log(`[${new Date().toLocaleTimeString()}] State update:`, data);
        if (data.state) {
            updateStateIndicator(data.state);
        }
    });

    socket.on('dashboard_data', (data) => {
        updateDashboardData(data);
        syncButton.classList.remove('syncing');
        syncButton.innerHTML = '<i class="fas fa-sync-alt"></i> Sync Dashboard';
    });

    socket.on('plugin_log', (log) => {
        addPluginLog(log);
    });

    socket.on('command_output', (data) => {
        handleCommandOutput(data);
    });

    socket.on('current_process', (data) => {
        handleCurrentProcess(data);
    });

    socket.on('register_action', (action) => {
        console.log(`[${new Date().toLocaleTimeString()}] Action registered:`, action);
        if (action && action.action_id) {
            registeredActions[action.action_id] = action;
            updateActionsPanel();
            // Use alertify for transient info popup
            alertify.notify(`New action available: ${action.action_name}`, 'info', 3);
        } else {
            console.error("Invalid action registration data received:", action);
        }
    });

    // Removed socket.on('alert_sync') - Handled by base template's socket.on('alert')

    // --- Event Handlers ---
    window.syncDashboard = function() {
        if (socket.connected) {
            console.log('Requesting dashboard sync...');
            socket.emit('sync_dashboard');
            showStatusMessage('Syncing dashboard data...', 2000, 'info');
            syncButton.classList.add('syncing');
            syncButton.innerHTML = '<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span> Syncing...';
        } else {
            // Use alertify for transient error popup
            alertify.error('Cannot sync: Not connected to server.');
        }
    };

    clearLogsButton.addEventListener('click', () => {
        pluginLogsTableBody.innerHTML = '<tr><td colspan="3" class="text-center p-3">Log display cleared.</td></tr>';
        alertify.message('Log display cleared');
    });

    autoScrollToggle.addEventListener('click', () => {
        autoScrollEnabled = !autoScrollEnabled;
        autoScrollToggle.innerHTML = autoScrollEnabled ?
            '<i class="fas fa-scroll"></i> Auto-scroll: ON' :
            '<i class="fas fa-scroll"></i> Auto-scroll: OFF';
        autoScrollToggle.classList.toggle('active', autoScrollEnabled);
        alertify.message(`Auto-scroll ${autoScrollEnabled ? 'enabled' : 'disabled'}`);
    });

    syncButton.addEventListener('click', window.syncDashboard);

    restartServiceButton.addEventListener('click', () => {
        const isBlacklisted = previousState === "CONNECTED_BLACKLISTED";
        const confirmMessage = isBlacklisted
            ? 'This will perform a security reset due to the blacklisted network. Are you sure?'
            : 'Are you sure you want to restart the Netfang service? This may interrupt monitoring briefly.';

        alertify.confirm(
            isBlacklisted ? 'Confirm Security Reset' : 'Confirm Service Restart',
            confirmMessage,
            async () => {
                showStatusMessage('Initiating restart...', 3000, 'info');
                restartServiceButton.disabled = true;
                restartServiceButton.innerHTML = '<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span> Restarting...';

                try {
                    const response = await fetch('/update', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' }
                    });
                    const data = await response.json();

                    if (response.ok && data.status === 'success') {
                        showStatusMessage(data.message || 'Service restart initiated.', 5000, 'success');
                        alertify.success(data.message || 'Service restart initiated.');
                    } else {
                        showStatusMessage(data.message || 'Failed to initiate restart.', 5000, 'error');
                        alertify.error(data.message || 'Failed to initiate restart.');
                        restartServiceButton.disabled = false;
                        updateButtonStyles(previousState);
                    }
                } catch (error) {
                    console.error("Error restarting service:", error);
                    showStatusMessage(`Error: ${error.message}`, 5000, 'error');
                    alertify.error(`Error initiating restart: ${error.message}`);
                    restartServiceButton.disabled = false;
                    updateButtonStyles(previousState);
                }
            },
            () => {
                alertify.message('Restart cancelled.');
            }
        ).set('labels', {ok:'Confirm', cancel:'Cancel'});
    });

    reInitNetfangButton.addEventListener('click', () => {
        alertify.confirm(
            'Confirm Database Reset',
            'WARNING: This will delete the entire NetFang database and restart the service. All network history, device information, and configuration will be lost. Are you sure you want to proceed?',
            async () => {
                showStatusMessage('Resetting NetFang database...', 3000, 'info');
                reInitNetfangButton.disabled = true;
                reInitNetfangButton.innerHTML = '<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span> Resetting...';

                try {
                    const response = await fetch('/reinit', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' }
                    });
                    const data = await response.json();

                    if (response.ok && (data.status === 'success' || data.status === 'partial')) {
                        showStatusMessage(data.message || 'NetFang database reset successfully.', 5000, 'success');
                        alertify.success(data.message || 'NetFang database reset successfully.');
                        setTimeout(window.syncDashboard, 3000);
                    } else {
                        showStatusMessage(data.message || 'Failed to reset NetFang database.', 5000, 'error');
                        alertify.error(data.message || 'Failed to reset NetFang database.');
                        reInitNetfangButton.disabled = false;
                        reInitNetfangButton.innerHTML = '<i class="fas fa-exclamation-triangle"></i> Delete Database and Restart';
                    }
                } catch (error) {
                    console.error("Error resetting NetFang:", error);
                    showStatusMessage(`Error: ${error.message}`, 5000, 'error');
                    alertify.error(`Error resetting NetFang: ${error.message}`);
                    reInitNetfangButton.disabled = false;
                    reInitNetfangButton.innerHTML = '<i class="fas fa-exclamation-triangle"></i> Delete Database and Restart';
                }
            },
            () => {
                alertify.message('Database reset cancelled.');
            }
        ).set('labels', {ok:'Reset Database', cancel:'Cancel'})
        .set('closable', false);
    });

    // Panel Collapse Toggle (Using Bootstrap's built-in JS via data attributes is often easier)
    document.querySelectorAll('.panel-header').forEach(header => {
        header.addEventListener('click', (e) => {
            // Prevent toggling if click is on a button inside the header
            if (e.target.closest('button, a')) return;

            const toggle = header.querySelector('.panel-toggle');
            const content = header.nextElementSibling;
            if (toggle && content && content.classList.contains('panel-content')) {
                // Properly use Bootstrap's Collapse API
                const bsCollapse = new bootstrap.Collapse(content, {
                    toggle: true
                });
                
                // Update arrow direction based on the current state
                // We need to use a different approach because Bootstrap's collapse events
                toggle.classList.toggle('collapsed');
            }
        });
    });

    // --- Initialization ---
    function startAutoSync() {
        if (autoSyncIntervalId) clearInterval(autoSyncIntervalId);
        autoSyncIntervalId = setInterval(window.syncDashboard, SYNC_INTERVAL);
        console.log(`Auto-sync started every ${SYNC_INTERVAL / 1000} seconds.`);
    }

    function stopAutoSync() {
        if (autoSyncIntervalId) {
            clearInterval(autoSyncIntervalId);
            autoSyncIntervalId = null;
            console.log('Auto-sync stopped.');
        }
    }

    document.addEventListener('DOMContentLoaded', () => {
        console.log('DOM fully loaded and parsed (Dashboard)');
        updateStateIndicator(previousState);
        initializeTooltips();
        setupActionButtons(); // Setup initial action button listeners on main content area

        // Initialize Bootstrap Collapse for panels that start collapsed
        document.querySelectorAll('.panel-content.collapsed').forEach(el => {
            new bootstrap.Collapse(el, { toggle: false }); // Initialize but don't toggle
        });


        if (socket.connected) {
            window.syncDashboard();
            startAutoSync();
        } else {
            console.log('Socket not connected on DOMContentLoaded, waiting for connect event.');
            networksTableBody.innerHTML = '<tr><td colspan="4" class="text-center p-3">Connecting to server...</td></tr>';
            devicesTableBody.innerHTML = '<tr><td colspan="5" class="text-center p-3">Connecting to server...</td></tr>';
        }
    });
</script>
{% endblock %}
