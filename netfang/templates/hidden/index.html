<!DOCTYPE html>
<html lang="{{ 'de' if request.accept_languages.best_match(['de','en'])=='de' else 'en' }}">
<head>
    <meta charset="UTF-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1.0"/>
    <title>NetFang Secured Router</title>

    <!-- Link to your CSS file -->
    <link rel="stylesheet" href="{{ url_for('static', filename='css/hidden.css') }}">

    <!-- Include Socket.IO client library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.8.1/socket.io.js"
            integrity="sha512-8BHxHDLsOHx+flIrQ0DrZcea7MkHqRU5GbTHmbdzMRnAaoCIkZ97PqZcXJkKZckMMhqfoeaJE+DNUVuyoQsO3Q=="
            crossorigin="anonymous" referrerpolicy="no-referrer"></script>

    <!-- AlertifyJS CSS -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/alertifyjs@1.13.1/build/css/alertify.min.css"/>
    <!-- AlertifyJS JavaScript -->
    <script src="https://cdn.jsdelivr.net/npm/alertifyjs@1.13.1/build/alertify.min.js"></script>

    <style>
        /* AlertifyJS Terminal Theme */
        .alertify-notifier .ajs-message {
            font-family: 'Source Code Pro', monospace;
            background-color: #121212;
            border: 1px solid #33FF33;
            color: #33FF33;
            box-shadow: 0 0 10px rgba(51, 255, 51, 0.5);
            text-shadow: 0 0 5px rgba(51, 255, 51, 0.7);
            border-radius: 0;
        }

        .alertify-notifier .ajs-message.ajs-error {
            border-color: #FF3333;
            color: #FF3333;
            text-shadow: 0 0 5px rgba(255, 51, 51, 0.7);
        }

        .alertify-notifier .ajs-message.ajs-warning {
            border-color: #FFCC00;
            color: #FFCC00;
            text-shadow: 0 0 5px rgba(255, 204, 0, 0.7);
        }

        /* Alert Panel Styles */
        #alertPanel {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 300px;
            max-height: 400px;
            background-color: rgba(18, 18, 18, 0.95);
            border: 1px solid #33FF33;
            border-radius: 0;
            overflow: hidden;
            transition: height 0.3s;
            z-index: 1000;
            box-shadow: 0 0 15px rgba(51, 255, 51, 0.3);
            display: flex;
            flex-direction: column;
        }

        #alertPanelHeader {
            padding: 8px;
            background-color: #000;
            border-bottom: 1px solid #33FF33;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
        }

        #alertPanelHeader h3 {
            margin: 0;
            font-size: 14px;
            color: #33FF33;
            text-shadow: 0 0 5px rgba(51, 255, 51, 0.7);
        }

        #alertCounter {
            background-color: #33FF33;
            color: #000;
            padding: 2px 6px;
            border-radius: 8px;
            font-size: 12px;
            font-weight: bold;
        }

        #alertList {
            overflow-y: auto;
            max-height: 350px;
            padding: 0;
            margin: 0;
            list-style: none;
        }

        .alert-item {
            padding: 8px 10px;
            border-bottom: 1px solid rgba(51, 255, 51, 0.2);
            font-size: 12px;
        }

        .alert-item-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 3px;
        }

        .alert-category {
            font-weight: bold;
            text-transform: uppercase;
        }

        .alert-timestamp {
            font-size: 10px;
            opacity: 0.7;
        }

        .alert-message {
            word-break: break-word;
        }

        .alert-item.info {
            color: #33FF33;
            border-left: 3px solid #33FF33;
        }

        .alert-item.warning {
            color: #FFCC00;
            border-left: 3px solid #FFCC00;
        }

        .alert-item.critical {
            color: #FF3333;
            border-left: 3px solid #FF3333;
        }

        .alert-item.resolved {
            opacity: 0.6;
        }

        .alert-resolved-badge {
            font-size: 9px;
            padding: 1px 4px;
            background-color: rgba(255, 255, 255, 0.2);
            border-radius: 3px;
            margin-left: 5px;
        }

        #alertControls {
            display: flex;
            padding: 5px;
            border-top: 1px solid rgba(51, 255, 51, 0.3);
            background-color: rgba(0, 0, 0, 0.3);
        }

        .alert-filter {
            background: none;
            border: 1px solid rgba(51, 255, 51, 0.5);
            color: #33FF33;
            font-size: 10px;
            padding: 2px 5px;
            margin-right: 5px;
            cursor: pointer;
            text-shadow: 0 0 5px rgba(51, 255, 51, 0.3);
        }

        .alert-filter.active {
            background-color: #33FF33;
            color: #000;
        }

        .notification-dot {
            width: 8px;
            height: 8px;
            background-color: #FF3333;
            border-radius: 50%;
            margin-left: 5px;
            display: none;
        }

        .notification-dot.visible {
            display: inline-block;
        }

        /* Dashboard panels for displaying DB data */
        .dashboard-container {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            margin-top: 20px;
            margin-bottom: 20px;
        }

        .dashboard-panel {
            flex: 1 1 300px;
            background-color: rgba(18, 18, 18, 0.8);
            border: 1px solid #33FF33;
            padding: 15px;
            box-shadow: 0 0 10px rgba(51, 255, 51, 0.2);
        }

        .dashboard-panel h2 {
            color: #33FF33;
            font-size: 16px;
            margin-top: 0;
            margin-bottom: 10px;
            border-bottom: 1px solid rgba(51, 255, 51, 0.3);
            padding-bottom: 5px;
        }

        .data-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 12px;
        }

        .data-table th {
            text-align: left;
            padding: 6px;
            border-bottom: 1px solid rgba(51, 255, 51, 0.5);
            color: #33FF33;
        }

        .data-table td {
            padding: 6px;
            border-bottom: 1px solid rgba(51, 255, 51, 0.2);
            color: #CCC;
        }

        .data-table tr:hover td {
            background-color: rgba(51, 255, 51, 0.05);
        }

        .sync-button {
            background: none;
            border: 1px solid #33FF33;
            color: #33FF33;
            padding: 8px 15px;
            cursor: pointer;
            margin-top: 10px;
            transition: all 0.3s;
        }

        .sync-button:hover {
            background-color: rgba(51, 255, 51, 0.1);
            box-shadow: 0 0 8px rgba(51, 255, 51, 0.5);
        }

        .service-button {
            background: none;
            border: 1px solid #FF3333;
            color: #FF3333;
            padding: 8px 15px;
            cursor: pointer;
            margin-top: 10px;
            transition: all 0.3s;
        }

        .service-button:hover {
            background-color: rgba(255, 51, 51, 0.1);
            box-shadow: 0 0 8px rgba(255, 51, 51, 0.5);
        }

        .status-message {
            margin-top: 5px;
            font-size: 12px;
            color: #33FF33;
            height: 15px;
        }

        .network-home {
            color: #33FF33;
        }

        .network-blacklisted {
            color: #FF3333;
        }
    </style>
</head>
<body>
<header>
    <div class="header-content">
        <!-- Router Logo + Title left-aligned -->
        <img src="{{ url_for('static', filename='router_logo.png') }}" alt="Router Logo" class="router-logo"/>
        <h1>NetFang Secured Router - {{ hostname }}</h1>

        <!-- Badge in top-right corner -->
        <span id="connectionBadge" class="badge disconnected">Unknown</span>
    </div>
</header>

<main>
    <div>
        <strong>NetFang Status:</strong>
        <span id="state">{{ state }}</span>
    </div>
    
    <div class="dashboard-container">
        <!-- Network Information -->
        <div class="dashboard-panel">
            <h2>Networks</h2>
            <div class="table-container">
                <table class="data-table" id="networksTable">
                    <thead>
                        <tr>
                            <th>MAC Address</th>
                            <th>Status</th>
                            <th>Last Seen</th>
                        </tr>
                    </thead>
                    <tbody>
                        <!-- Data will be populated by JavaScript -->
                    </tbody>
                </table>
            </div>
        </div>
        
        <!-- Devices Information -->
        <div class="dashboard-panel">
            <h2>Devices</h2>
            <div class="table-container">
                <table class="data-table" id="devicesTable">
                    <thead>
                        <tr>
                            <th>IP Address</th>
                            <th>MAC Address</th>
                            <th>Hostname</th>
                        </tr>
                    </thead>
                    <tbody>
                        <!-- Data will be populated by JavaScript -->
                    </tbody>
                </table>
            </div>
        </div>
        
        <!-- Plugin Logs -->
        <div class="dashboard-panel">
            <h2>Plugin Logs</h2>
            <div class="table-container">
                <table class="data-table" id="pluginLogsTable">
                    <thead>
                        <tr>
                            <th>Plugin</th>
                            <th>Event</th>
                            <th>Timestamp</th>
                        </tr>
                    </thead>
                    <tbody>
                        <!-- Data will be populated by JavaScript -->
                    </tbody>
                </table>
            </div>
        </div>
    </div>
    
    <div class="dashboard-controls">
        <button id="syncButton" class="sync-button">Sync Dashboard</button>
        <button id="restartServiceButton" class="service-button">Restart Netfang Service</button>
        <div id="statusMessage" class="status-message"></div>
    </div>
    
    <a href="{{ url_for('test_page') }}" class="button">Perform Tests</a>
</main>

<footer>
    <p>&copy; 2025 NetFang.
        {{ 'Alle Rechte vorbehalten.' if request.accept_languages.best_match(['de','en'])=='de' else 'All rights reserved.' }}
    </p>
</footer>

<!-- Alert Panel -->
<div id="alertPanel">
    <div id="alertPanelHeader">
        <h3>System Notifications <span class="notification-dot" id="newAlertDot"></span></h3>
        <span id="alertCounter">0</span>
    </div>
    <ul id="alertList"></ul>
    <div id="alertControls">
        <button class="alert-filter active" data-filter="all">All</button>
        <button class="alert-filter" data-filter="active">Active</button>
        <button class="alert-filter" data-filter="info">Info</button>
        <button class="alert-filter" data-filter="warning">Warning</button>
        <button class="alert-filter" data-filter="critical">Critical</button>
    </div>
</div>

<script>
    const stateElement = document.getElementById("state");
    const badgeElement = document.getElementById("connectionBadge");
    let previousState = '{{ state }}';

    // Translations for the badge
    const connectedText = "{{ 'Verbunden mit NetFang' if request.accept_languages.best_match(['de','en'])=='de' else 'Connected to NetFang' }}";
    const disconnectedText = "{{ 'Getrennt von NetFang' if request.accept_languages.best_match(['de','en'])=='de' else 'Disconnected from NetFang' }}";

    let currentIntervalID = null;

    // Typewriter effect for 'state'
    function typeText(element, text) {
        if (currentIntervalID !== null) {
            clearInterval(currentIntervalID);
        }
        let index = 0;
        element.innerText = '';
        currentIntervalID = setInterval(() => {
            if (index < text.length) {
                element.innerText += text.charAt(index);
                index++;
            } else {
                clearInterval(currentIntervalID);
                currentIntervalID = null;
            }
        }, 50);
    }

    // Initialize Socket.IO connection
    const socket = io();

    socket.on('connect', () => {
        badgeElement.classList.remove("disconnected");
        badgeElement.classList.add("connected");
        badgeElement.textContent = connectedText;
        
        // Request initial dashboard data when connected
        socket.emit('sync_dashboard');
    });

    socket.on('disconnect', () => {
        badgeElement.classList.remove("connected");
        badgeElement.classList.add("disconnected");
        badgeElement.textContent = disconnectedText;
    });

    // Listen for state updates from the server
    socket.on("state_update", (data) => {
        console.log(`[${new Date().toLocaleTimeString()}] State update received:`, data);
        const newState = data.state || 'Unknown';

        if (newState !== previousState) {
            previousState = newState;
            typeText(stateElement, newState);
        }
    });

    // Dashboard Data Management
    (function() {
        // Get DOM elements
        const networksTable = document.getElementById('networksTable').getElementsByTagName('tbody')[0];
        const devicesTable = document.getElementById('devicesTable').getElementsByTagName('tbody')[0];
        const pluginLogsTable = document.getElementById('pluginLogsTable').getElementsByTagName('tbody')[0];
        const syncButton = document.getElementById('syncButton');
        const restartServiceButton = document.getElementById('restartServiceButton');
        const statusMessage = document.getElementById('statusMessage');
        
        // Format timestamp for display
        function formatTimestamp(timestamp) {
            try {
                const date = new Date(timestamp);
                return date.toLocaleString();
            } catch (e) {
                return 'Invalid time';
            }
        }
        
        // Handle dashboard data sync
        function updateDashboardData(data) {
            // Clear existing tables
            networksTable.innerHTML = '';
            devicesTable.innerHTML = '';
            pluginLogsTable.innerHTML = '';
            
            // Populate Networks table
            data.networks.forEach(network => {
                const row = networksTable.insertRow();
                
                const statusClass = network.is_home ? 'network-home' : 
                                   (network.is_blacklisted ? 'network-blacklisted' : '');
                
                const statusText = network.is_home ? 'Home' : 
                                  (network.is_blacklisted ? 'Blacklisted' : 'Known');
                
                row.innerHTML = `
                    <td>${network.mac_address}</td>
                    <td class="${statusClass}">${statusText}</td>
                    <td>${formatTimestamp(network.last_seen)}</td>
                `;
            });
            
            // Populate Devices table
            data.devices.forEach(device => {
                const row = devicesTable.insertRow();
                row.innerHTML = `
                    <td>${device.ip_address || 'N/A'}</td>
                    <td>${device.mac_address || 'N/A'}</td>
                    <td>${device.hostname || 'Unknown'}</td>
                `;
            });
            
            // Populate Plugin Logs table
            data.plugin_logs.forEach(log => {
                const row = pluginLogsTable.insertRow();
                row.innerHTML = `
                    <td>${log.plugin_name}</td>
                    <td>${log.event}</td>
                    <td>${formatTimestamp(log.timestamp)}</td>
                `;
            });
            
            // Show success message
            statusMessage.textContent = `Dashboard updated at ${new Date().toLocaleTimeString()}`;
            setTimeout(() => {
                statusMessage.textContent = '';
            }, 3000);
        }
        
        // Listen for dashboard data from the server
        socket.on('dashboard_data', (data) => {
            console.log(`[${new Date().toLocaleTimeString()}] Dashboard data received:`, data);
            updateDashboardData(data);
        });
        
        // Handle manual sync button click
        syncButton.addEventListener('click', () => {
            socket.emit('sync_dashboard');
            statusMessage.textContent = 'Syncing...';
        });
        
        // Handle service restart button
        restartServiceButton.addEventListener('click', async () => {
            if (confirm('Are you sure you want to restart the Netfang service?')) {
                statusMessage.textContent = 'Restarting service...';
                
                try {
                    const response = await fetch('/update', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        }
                    });
                    
                    const data = await response.json();
                    
                    if (data.status === 'success') {
                        statusMessage.textContent = data.message;
                        // Show success notification
                        alertify.success(data.message, 5);
                    } else {
                        statusMessage.textContent = data.message;
                        // Show error notification
                        alertify.error(data.message, 5);
                    }
                } catch (error) {
                    statusMessage.textContent = `Error: ${error.message}`;
                    alertify.error(`Error restarting service: ${error.message}`, 5);
                }
                
                // Clear status message after 5 seconds
                setTimeout(() => {
                    statusMessage.textContent = '';
                }, 5000);
            }
        });
        
        // Auto-refresh dashboard data every 30 seconds
        setInterval(() => {
            socket.emit('sync_dashboard');
        }, 30000);
    })();

    // Alert System Implementation
    (function () {
        // Initialize variables for alert management
        const alerts = [];
        let currentFilter = 'all';
        let isPanelOpen = true;
        let hasNewAlerts = false;

        // Get DOM elements
        const alertPanel = document.getElementById('alertPanel');
        const alertPanelHeader = document.getElementById('alertPanelHeader');
        const alertList = document.getElementById('alertList');
        const alertCounter = document.getElementById('alertCounter');
        const newAlertDot = document.getElementById('newAlertDot');
        const filterButtons = document.querySelectorAll('.alert-filter');

        // Configure AlertifyJS
        alertify.defaults.notifier.position = "bottom-right";
        alertify.defaults.notifier.delay = 5;

        // Toggle alert panel visibility
        alertPanelHeader.addEventListener('click', () => {
            isPanelOpen = !isPanelOpen;
            alertList.style.display = isPanelOpen ? 'block' : 'none';
            document.getElementById('alertControls').style.display = isPanelOpen ? 'flex' : 'none';

            if (isPanelOpen && hasNewAlerts) {
                hasNewAlerts = false;
                newAlertDot.classList.remove('visible');
            }
        });

        // Set up filter buttons
        filterButtons.forEach(button => {
            button.addEventListener('click', () => {
                // Remove active class from all buttons
                filterButtons.forEach(btn => btn.classList.remove('active'));

                // Add active class to clicked button
                button.classList.add('active');

                // Update filter and refresh list
                currentFilter = button.getAttribute('data-filter');
                renderAlertList();
            });
        });

        // Format timestamp to local time
        function formatTimestamp(timestamp) {
            try {
                const date = new Date(timestamp);
                const pad = n => n < 10 ? '0' + n : n;
                return `${pad(date.getHours())}:${pad(date.getMinutes())}`;
            } catch (e) {
                return 'Invalid time';
            }
        }

        // Render alert list based on current filter
        function renderAlertList() {
            // Clear current list
            alertList.innerHTML = '';

            // Filter alerts
            let filteredAlerts = [...alerts];

            if (currentFilter === 'active') {
                filteredAlerts = filteredAlerts.filter(alert => !alert.is_resolved);
            } else if (['info', 'warning', 'critical'].includes(currentFilter)) {
                filteredAlerts = filteredAlerts.filter(alert => alert.level === currentFilter);
            }

            // Sort alerts by timestamp, newest first
            filteredAlerts.sort((a, b) => {
                return new Date(b.timestamp) - new Date(a.timestamp);
            });

            // Update alert counter
            const activeCount = alerts.filter(alert => !alert.is_resolved).length;
            alertCounter.textContent = activeCount;

            // Create alert items
            filteredAlerts.forEach(alert => {
                const alertItem = document.createElement('li');
                alertItem.className = `alert-item ${alert.level} ${alert.is_resolved ? 'resolved' : ''}`;

                const alertHeader = document.createElement('div');
                alertHeader.className = 'alert-item-header';

                const category = document.createElement('span');
                category.className = 'alert-category';
                category.textContent = alert.category;

                if (alert.is_resolved) {
                    const resolvedBadge = document.createElement('span');
                    resolvedBadge.className = 'alert-resolved-badge';
                    resolvedBadge.textContent = 'RESOLVED';
                    category.appendChild(resolvedBadge);
                }

                const timestamp = document.createElement('span');
                timestamp.className = 'alert-timestamp';
                timestamp.textContent = formatTimestamp(alert.timestamp);

                alertHeader.appendChild(category);
                alertHeader.appendChild(timestamp);

                const message = document.createElement('div');
                message.className = 'alert-message';
                message.textContent = alert.message;

                alertItem.appendChild(alertHeader);
                alertItem.appendChild(message);

                alertList.appendChild(alertItem);
            });

            // Show message when no alerts match filter
            if (filteredAlerts.length === 0) {
                const emptyItem = document.createElement('li');
                emptyItem.className = 'alert-item';
                emptyItem.textContent = 'No notifications to display';
                alertList.appendChild(emptyItem);
            }
        }

        // Add a new alert
        function addAlert(alert) {
            // Check if alert already exists (by ID)
            const existingIndex = alerts.findIndex(a => a.id === alert.id);

            if (existingIndex !== -1) {
                // Update existing alert
                alerts[existingIndex] = alert;
            } else {
                // Add new alert
                alerts.push(alert);

                // Show notification dot if panel is closed
                if (!isPanelOpen) {
                    hasNewAlerts = true;
                    newAlertDot.classList.add('visible');
                }

                // Show toast notification for new unresolved alerts
                if (!alert.is_resolved) {
                    showToastNotification(alert);
                }
            }

            // Re-render the alert list
            renderAlertList();
        }

        // Show toast notification
        function showToastNotification(alert) {
            let duration = alert.autodismisses_after || 5;

            switch (alert.level) {
                case "critical":
                    alertify.error(alert.message, duration);
                    break;
                case "warning":
                    alertify.warning(alert.message, duration);
                    break;
                default: // info
                    alertify.success(alert.message, duration);
            }
        }

        // Socket.IO event handlers
        socket.on("alert_sync", function (alert) {
            console.log(`[${new Date().toLocaleTimeString()}] Alert received:`, alert);
            addAlert(alert);
        });

        socket.on("all_alerts", function (alertsData) {
            console.log(`[${new Date().toLocaleTimeString()}] All alerts received:`, alertsData);

            // Process all alerts
            alertsData.forEach(alert => {
                addAlert(alert);
            });
        });

        // Initialize alert panel
        renderAlertList();
    })();
</script>
</body>
</html>
