{% extends "hidden/hidden_structure.html" %}

{% block title %}NetFang Secured Router{% endblock %}

{% block header_title %}NetFang Secured Router - {{ hostname }}{% endblock %}

{% block main_content %}
    <div class="state-indicator">
        <strong>NetFang Status:</strong>
        <span id="state">{{ state }}</span>
        <div id="scanningIndicator" class="scanning-indicator">
            <div class="scanning-pulse"></div>
            <span>Scanning network...</span>
        </div>
        <div class="state-status-bar">
            <div class="state-status-progress"></div>
        </div>
        <div id="stateDescription" class="state-description mt-2"></div>
    </div>
    
    <div class="dashboard-container">
        <!-- Network Information -->
        <div class="dashboard-panel">
            <div class="panel-header">
                <h2>Networks</h2>
                <span class="panel-toggle">▼</span>
            </div>
            <div class="panel-content">
                <div class="table-container">
                    <table class="data-table" id="networksTable">
                        <thead>
                            <tr>
                                <th>MAC Address</th>
                                <th>Status</th>
                                <th>Last Seen</th>
                            </tr>
                        </thead>
                        <tbody>
                            <!-- Data will be populated by JavaScript -->
                        </tbody>
                    </table>
                </div>
            </div>
        </div>
        
        <!-- Devices Information -->
        <div class="dashboard-panel">
            <div class="panel-header">
                <h2>Devices</h2>
                <span class="panel-toggle">▼</span>
            </div>
            <div class="panel-content">
                <div class="table-container">
                    <table class="data-table" id="devicesTable">
                        <thead>
                            <tr>
                                <th>IP Address</th>
                                <th>MAC Address</th>
                                <th>Vendor</th>
                                <th>Actions</th>
                            </tr>
                        </thead>
                        <tbody>
                            <!-- Data will be populated by JavaScript -->
                        </tbody>
                    </table>
                </div>
            </div>
        </div>
        
        <!-- Plugin Logs -->
        <div class="dashboard-panel">
            <div class="panel-header">
                <h2>Plugin Logs</h2>
                <span class="panel-toggle collapsed">▼</span>
            </div>
            <div class="panel-content collapsed">
                <div class="table-container">
                    <table class="data-table" id="pluginLogsTable">
                        <thead>
                            <tr>
                                <th>Plugin</th>
                                <th>Event</th>
                                <th>Timestamp</th>
                            </tr>
                        </thead>
                        <tbody>
                            <!-- Data will be populated by JavaScript -->
                        </tbody>
                    </table>
                </div>
            </div>
        </div>
    </div>
    
    <div class="dashboard-controls">
        <button id="syncButton" class="sync-button">Sync Dashboard</button>
        <button id="restartServiceButton" class="service-button">Restart Netfang Service</button>
        <div id="statusMessage" class="status-message"></div>
    </div>
{% endblock %}

{% block additional_scripts %}
<script>
    // Configure alertify defaults
    alertify.defaults.notifier.position = 'top-right';
    alertify.defaults.notifier.delay = 5;
    alertify.defaults.transition = "slide";
    alertify.defaults.theme.ok = "btn btn-primary";
    alertify.defaults.theme.cancel = "btn btn-danger";
    alertify.defaults.theme.input = "form-control";

    const stateElement = document.getElementById("state");
    const scanningIndicator = document.getElementById("scanningIndicator");
    const stateIndicator = document.querySelector(".state-indicator");
    const stateStatusProgress = document.querySelector(".state-status-progress");
    const stateDescription = document.getElementById("stateDescription");
    const dashboardContainer = document.querySelector(".dashboard-container");
    let previousState = '{{ state }}';
    let currentIntervalID = null;
    let scanCompletedTimeout = null;

    // Initialize state descriptions
    const stateDescriptions = {
        'WAITING_FOR_NETWORK': 'NetFang is waiting for a network connection. Please check your network cable or Wi-Fi connection.',
        'DISCONNECTED': 'Network connection lost. NetFang will automatically try to reconnect when a network is available.',
        'RECONNECTING': 'Attempting to reconnect to the network...',
        'CONNECTING': 'Establishing connection to the network...',
        'CONNECTED_KNOWN': 'Connected to a known network. Network scan completed. Enhanced security features are active.',
        'CONNECTED_HOME': 'Connected to your home network. Network scan completed. Full security features are active.',
        'CONNECTED_NEW': 'Connected to a new, unrecognized network. Network scan completed with security measures in place.',
        'CONNECTED_BLACKLISTED': 'Warning: Connected to a blacklisted network! Enhanced protection measures activated.',
        'SCANNING_IN_PROGRESS': 'Network scan in progress. Discovering devices and potential threats...',
        'SCAN_COMPLETED': 'Network scan completed. Results have been analyzed and security measures are in place.',
        'PERFORM_ACTION': 'Executing security action...'
    };

    // Update the state indicator, progress bar, and container styling based on current state
    function updateStateIndicator(state) {
        // Remove any existing state classes
        stateIndicator.className = "state-indicator";
        
        // Add the new state class
        stateIndicator.classList.add(`state-${state}`);
        
        // Add class to dashboard container for broader styling
        dashboardContainer.className = "dashboard-container";
        dashboardContainer.classList.add(`dashboard-state-${state}`);
        
        // Update progress bar visibility and animation based on state
        if (state === "SCANNING_IN_PROGRESS" || state === "CONNECTING" || state === "RECONNECTING") {
            scanningIndicator.classList.add('active');
            stateStatusProgress.style.animation = "progressAnim 2s infinite";
            
            // For scanning state, show an alertify notification if not already shown
            if (state === "SCANNING_IN_PROGRESS") {
                alertify.notify('Network scan in progress...', 'info', 0, function(){});
            }
        } else {
            scanningIndicator.classList.remove('active');
            stateStatusProgress.style.animation = "none";
            
            // Clear any existing scan completed timeout
            if (scanCompletedTimeout) {
                clearTimeout(scanCompletedTimeout);
                scanCompletedTimeout = null;
            }
            
            // Dismiss any persistent notifications
            alertify.dismissAll();
            
            // Set fixed progress for complete states
            if (state === "CONNECTED_HOME" || state === "CONNECTED_KNOWN" || state === "SCAN_COMPLETED") {
                stateStatusProgress.style.width = "100%";
                
                // If transition from scanning to completed, show a success notification
                if (previousState === "SCANNING_IN_PROGRESS" && state === "SCAN_COMPLETED") {
                    alertify.success('Network scan completed successfully!');
                    
                    // After scan completes, we'll stay on SCAN_COMPLETED temporarily then auto-transition back
                    // to the appropriate connected state after a few seconds (this is cosmetic only)
                    scanCompletedTimeout = setTimeout(() => {
                        // This will be handled by the server but we'll update the UI proactively
                        // for a smoother experience
                        syncDashboard();
                    }, 5000);
                }
            } else if (state === "CONNECTED_NEW") {
                stateStatusProgress.style.width = "75%";
            } else if (state === "CONNECTED_BLACKLISTED") {
                stateStatusProgress.style.width = "100%";
                stateStatusProgress.style.background = "linear-gradient(to right, #ef5350, #e57373)";
                
                // Show a warning notification for blacklisted networks
                alertify.error('Warning: Connected to a blacklisted network!', 0);
            } else if (state === "DISCONNECTED" || state === "WAITING_FOR_NETWORK") {
                stateStatusProgress.style.width = "25%";
                
                // Show a notification for disconnection
                if (previousState !== "DISCONNECTED" && previousState !== "WAITING_FOR_NETWORK") {
                    alertify.warning('Network connection lost.');
                }
            } else {
                stateStatusProgress.style.width = "50%";
            }
        }
        
        // Update state description
        stateDescription.textContent = stateDescriptions[state] || '';
        
        // Update the buttons style based on state
        updateButtonStyles(state);
        
        // Adjust table headers based on state
        updateTableStyles(state);
    }
    
    // Update button styles based on state
    function updateButtonStyles(state) {
        const syncButton = document.getElementById('syncButton');
        const restartButton = document.getElementById('restartServiceButton');
        
        // Reset button classes
        syncButton.className = 'sync-button';
        restartButton.className = 'service-button';
        
        if (state === "CONNECTED_BLACKLISTED") {
            restartButton.classList.add('warning-button');
            restartButton.textContent = "Security Reset";
        } else {
            restartButton.textContent = "Restart Netfang Service";
        }
        
        if (state === "SCANNING_IN_PROGRESS") {
            syncButton.disabled = true;
            syncButton.classList.add('disabled-button');
        } else {
            syncButton.disabled = false;
            syncButton.classList.remove('disabled-button');
        }
    }
    
    // Update table styling based on state
    function updateTableStyles(state) {
        const tableHeaders = document.querySelectorAll('.data-table th');
        
        // Reset all table header styles
        tableHeaders.forEach(th => {
            th.style.backgroundColor = '';
            th.style.color = '';
            th.style.borderBottomColor = '';
        });
        
        // Apply state-specific styles
        if (state === "CONNECTED_BLACKLISTED") {
            tableHeaders.forEach(th => {
                th.style.backgroundColor = '#ffebee';
                th.style.borderBottomColor = '#ef5350';
            });
        } else if (state === "CONNECTED_HOME" || state === "SCAN_COMPLETED") {
            tableHeaders.forEach(th => {
                th.style.backgroundColor = '#e8f5e9';
                th.style.borderBottomColor = '#43a047';
            });
        } else if (state === "SCANNING_IN_PROGRESS") {
            tableHeaders.forEach(th => {
                th.style.backgroundColor = '#e0f7fa';
                th.style.borderBottomColor = '#26c6da';
            });
        }
    }

    // Initialize collapsible panels
    document.querySelectorAll('.panel-header').forEach(header => {
        header.addEventListener('click', () => {
            const toggle = header.querySelector('.panel-toggle');
            const content = header.nextElementSibling;
            
            toggle.classList.toggle('collapsed');
            content.classList.toggle('collapsed');
        });
    });

    // Typewriter effect for 'state'
    function typeText(element, text) {
        if (currentIntervalID !== null) {
            clearInterval(currentIntervalID);
        }
        let index = 0;
        element.innerText = '';
        currentIntervalID = setInterval(() => {
            if (index < text.length) {
                element.innerText += text.charAt(index);
                index++;
            } else {
                clearInterval(currentIntervalID);
                currentIntervalID = null;
            }
        }, 50);
    }

    // Listen for state updates from the server
    socket.on("state_update", (data) => {
        console.log(`[${new Date().toLocaleTimeString()}] State update received:`, data);
        const newState = data.state || 'Unknown';

        if (newState !== previousState) {
            // Update state display
            typeText(stateElement, newState);
            updateStateIndicator(newState);
            
            // Record new state
            previousState = newState;
        }
    });

    // Check initial state for scanning and update indicator
    updateStateIndicator(previousState);

    // Dashboard Data Management
    (function() {
        // Get DOM elements
        const networksTable = document.getElementById('networksTable').getElementsByTagName('tbody')[0];
        const devicesTable = document.getElementById('devicesTable').getElementsByTagName('tbody')[0];
        const pluginLogsTable = document.getElementById('pluginLogsTable').getElementsByTagName('tbody')[0];
        const syncButton = document.getElementById('syncButton');
        const restartServiceButton = document.getElementById('restartServiceButton');
        const statusMessage = document.getElementById('statusMessage');
        
        // Format timestamp for display
        function formatTimestamp(timestamp) {
            try {
                const date = new Date(timestamp);
                return date.toLocaleString();
            } catch (e) {
                return 'Invalid time';
            }
        }
        
        // Toggle fingerprint display
        function setupFingerprintToggles() {
            document.querySelectorAll('.show-fingerprint').forEach(button => {
                button.addEventListener('click', function() {
                    const dataElement = this.nextElementSibling;
                    if (dataElement.style.display === 'block') {
                        dataElement.style.display = 'none';
                        this.textContent = 'Show Fingerprint';
                    } else {
                        dataElement.style.display = 'block';
                        this.textContent = 'Hide Fingerprint';
                    }
                });
            });
        }
        
        // Handle dashboard data sync
        function updateDashboardData(data) {
            // Clear existing tables
            networksTable.innerHTML = '';
            devicesTable.innerHTML = '';
            pluginLogsTable.innerHTML = '';
            
            // Populate Networks table
            data.networks.forEach(network => {
                const row = networksTable.insertRow();
                
                const statusClass = network.is_home ? 'network-home' : 
                                   (network.is_blacklisted ? 'network-blacklisted' : '');
                
                const statusText = network.is_home ? 'Home' : 
                                  (network.is_blacklisted ? 'Blacklisted' : 'Known');
                
                row.innerHTML = `
                    <td>${network.mac_address}</td>
                    <td class="${statusClass}">${statusText}</td>
                    <td>${formatTimestamp(network.last_seen)}</td>
                `;
            });
            
            // Populate Devices table
            data.devices.forEach(device => {
                const row = devicesTable.insertRow();
                
                // Check if we have fingerprint data
                const hasFingerprintData = device.fingerprint && device.fingerprint !== 'None';
                const fingerprintHtml = hasFingerprintData ? 
                    `<span class="show-fingerprint">Show Fingerprint</span>
                     <div class="fingerprint-data">${device.fingerprint}</div>` : '';
                
                row.innerHTML = `
                    <td>${device.ip_address || 'N/A'}</td>
                    <td>${device.mac_address || 'N/A'}</td>
                    <td>${device.vendor || 'Unknown'}</td>
                    <td>${fingerprintHtml}</td>
                `;
            });
            
            // Populate Plugin Logs table - show most recent logs first
            data.plugin_logs.sort((a, b) => {
                return new Date(b.timestamp) - new Date(a.timestamp);
            }).forEach(log => {
                const row = pluginLogsTable.insertRow();
                row.innerHTML = `
                    <td>${log.plugin_name}</td>
                    <td>${log.event}</td>
                    <td>${formatTimestamp(log.timestamp)}</td>
                `;
            });
            
            // Set up fingerprint toggle buttons
            setupFingerprintToggles();
            
            // Show success message with animation
            statusMessage.textContent = `Dashboard updated at ${new Date().toLocaleTimeString()}`;
            statusMessage.style.opacity = 1;
            
            setTimeout(() => {
                statusMessage.style.opacity = 0;
            }, 3000);
        }
        
        // Listen for dashboard data from the server
        socket.on('dashboard_data', (data) => {
            console.log(`[${new Date().toLocaleTimeString()}] Dashboard data received:`, data);
            updateDashboardData(data);
        });
        
        // Sync dashboard function
        function syncDashboard() {
            socket.emit('sync_dashboard');
            statusMessage.textContent = 'Syncing...';
            statusMessage.style.opacity = 1;
            syncButton.classList.add('syncing');
            
            setTimeout(() => {
                syncButton.classList.remove('syncing');
            }, 1000);
        }
        
        // Handle manual sync button click
        syncButton.addEventListener('click', syncDashboard);
        
        // Handle service restart button
        restartServiceButton.addEventListener('click', async () => {
            if (confirm('Are you sure you want to restart the Netfang service?')) {
                statusMessage.textContent = 'Restarting service...';
                statusMessage.style.opacity = 1;
                
                try {
                    const response = await fetch('/update', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        }
                    });
                    
                    const data = await response.json();
                    
                    if (data.status === 'success') {
                        statusMessage.textContent = data.message;
                        // Show success notification
                        alertify.success(data.message, 5);
                    } else {
                        statusMessage.textContent = data.message;
                        // Show error notification
                        alertify.error(data.message, 5);
                    }
                } catch (error) {
                    statusMessage.textContent = `Error: ${error.message}`;
                    alertify.error(`Error restarting service: ${error.message}`, 5);
                }
                
                // Clear status message after 5 seconds
                setTimeout(() => {
                    statusMessage.style.opacity = 0;
                }, 5000);
            }
        });
        
        // Auto-refresh dashboard data every 30 seconds
        setInterval(syncDashboard, 30000);
        
        // Export sync function to global scope
        window.syncDashboard = syncDashboard;
    })();

    // Request initial dashboard data when connected
    document.addEventListener('DOMContentLoaded', function() {
        syncDashboard();
    });
</script>
{% endblock %}